[
  {
    "objectID": "posts/ai-assistants/index.html",
    "href": "posts/ai-assistants/index.html",
    "title": "A Critical Evaluation of Github Copilot and GPT-4 in a Data Science Workflow",
    "section": "",
    "text": "AI assistants like Github Copilot and ChatGPT promise breakthrough productivity improvements for developers. In this article, I’ll explore how these tools can be used in a data science workflow and evaluate their usefulness across 5 real-world tasks.\nThe main takeaway: Assistants greatly speed up coding using common libraries, but are less helpful for other tasks that go into a successful project."
  },
  {
    "objectID": "posts/ai-assistants/index.html#my-setup-vscode-raycast-ai",
    "href": "posts/ai-assistants/index.html#my-setup-vscode-raycast-ai",
    "title": "A Critical Evaluation of Github Copilot and GPT-4 in a Data Science Workflow",
    "section": "My setup: VSCode + Raycast AI",
    "text": "My setup: VSCode + Raycast AI\nBefore we dive into the tasks, let me describe my setup. I use VSCode with Copilot and GPT-4 via Raycast AI. Raycast AI provides a chat box that connects to GPT-4 and has a shortcut and one-tap copy of suggested code. I also have some shortcuts in Raycast AI to speed up my workflow:\n\nFind bugs in my code\nImprove this code\nExplain code step by step\n\n\n\n\nRaycast Commands\n\n\nAs an example, running “Improve this code” on a selection of text will send it to GPT-4, with the instruction\n\nCheck the following code and give advice on how to make it more reliable, secure and easy to read.\n\n\n\n\nRaycast Commands Detail"
  },
  {
    "objectID": "posts/ai-assistants/index.html#example-tasks",
    "href": "posts/ai-assistants/index.html#example-tasks",
    "title": "A Critical Evaluation of Github Copilot and GPT-4 in a Data Science Workflow",
    "section": "Example tasks",
    "text": "Example tasks\nAs a data scientist on a small team, I wear many hats, from machine learning engineer to cloud architect. Consequently, I often have to work with languages, libraries and tools that I don’t have much experience with.\nHere are 5 tasks I worked on in the last few weeks and my evaluation of how much AI tools have helped me.\n\n1. Writing a Python script to evaluate a model\nThe first task was to write a Python script to evaluate Azure’s PII redaction API on a dataset of social media posts containing PII. The task mainly involved writing pandas code to load data and calculate metrics. Copilot was helpful in speeding up the process by suggesting entire sections of code that I could use without modifications.\nUsefulness: 5/5\n\n\n\nPandas\n\n\n\n\n2. Defining AWS infrastructure using Terraform\nNext, a colleague and I set up a database migration using AWS Database Migration Service (DMS), set up via Terraform. I asked GPT-4 to generate the configuration, and then I asked it more detailed questions, such as how to convert data types. However, the model frequently hallucinated: it made up options that don’t actually exist in AWS DMS. Overall, it was more confusing than helpful.\nUsefulness: 1/5\n\n\n3. Creating, testing and documenting models in dbt\nI created, tested, and documented models in dbt. Copilot made writing SQL for the models faster and was especially good at speeding up my workflow of documenting those models in the schema.yml files. However, since it didn’t know the database schema, it hallucinated tables and columns that don’t exist. GPT-4 was useful for thinking through the deployment of dbt-core on AWS ECS, especially the use of environment variables and the project.yml config file.\nUsefulness: 3/5\n\n\n4. Adjusting a web scraper in JavaScript\nFor the next task, I heavily relied on GPT-4. I had to adjust a web scraper to cover a different path of the target website. The scraper is written in JavaScript, which I’m not familiar with. Here, the “explain step-by-step” shortcut was helpful. GPT-4 was like an expert JS dev patiently explaining the code line by line. However, GPT-4 couldn’t see the target website and didn’t have access to the website’s html. Copying it over was tedious. I found it easier to use the SelectorGadget Chrome extension to find relevant CSS selectors.\nUsefulness: 4/5\n\n\n5. Choosing a dashboard tool\nA new project required building a dashboard, and it was my task to evaluate tools based on features, usability, and price. I tested many GUI-based tools (Metabase, Superset, Tableau, PowerBI and others). GPT-4 could list relevant decision criteria but couldn’t make the decision for me. It wasn’t useful as an information source because of the knowledge cutoff in 2021.\n\n\n\nDashboard"
  },
  {
    "objectID": "posts/ai-assistants/index.html#takeaways",
    "href": "posts/ai-assistants/index.html#takeaways",
    "title": "A Critical Evaluation of Github Copilot and GPT-4 in a Data Science Workflow",
    "section": "10 Takeaways",
    "text": "10 Takeaways\n\nCopilot and GPT-4 are at their best helping to write code in commonly used libraries like pandas.\nAs text-based models, Copilot and GPT-4 provide better help for code (text) based apps than GUIs.\nAI assistants are at their best in small projects with a low number of files, ideally just one notebook.\nThey are ideal for working on simple tasks in languages that you’re not familiar with.\nThe models don’t have the context of your project, company, and client, which are critical for more strategic decisions.\nThere’s no good tooling for showing GPT-4 data frames or tables in SQL. This limitation means it can’t contribute to the interpretation.\nThe 2021 training data cutoff for GPT-4 diminishes its usefulness for information retrieval.\nRubber duck debugging is an effective technique for overcoming blocks. Now we have v2 with a duck that can reply. Chatting with GPT-4 about programming challenges helped me.\nLLMs are best for delegating details, so you can focus on the bigger picture. Knowing what and how to ask is critical and being aware of typical sources of hallucinations.\nGPT-4 currently can’t run a non-trivial data science project by itself. It’s more independent than Copilot but not good enough to be an autopilot."
  },
  {
    "objectID": "posts/ai-assistants/index.html#differentiating-yourself-as-a-data-scientist-in-an-ai-future",
    "href": "posts/ai-assistants/index.html#differentiating-yourself-as-a-data-scientist-in-an-ai-future",
    "title": "A Critical Evaluation of Github Copilot and GPT-4 in a Data Science Workflow",
    "section": "Differentiating yourself as a data scientist in an AI-future",
    "text": "Differentiating yourself as a data scientist in an AI-future\nSo what sets a successful data scientist apart in a world with powerful AI assistants?\n\nUnderstanding of the domain and business\nBuilding trust with clients\nIdentifying the right questions to work on and the best format to report answers\nSystems design and overview of the project\nDetect hallucinations of AI models\n\nKnowing how to code is not enough to differentiate oneself."
  },
  {
    "objectID": "posts/ai-assistants/index.html#early-on-the-long-arc-of-innovation",
    "href": "posts/ai-assistants/index.html#early-on-the-long-arc-of-innovation",
    "title": "A Critical Evaluation of Github Copilot and GPT-4 in a Data Science Workflow",
    "section": "Early on the long arc of innovation",
    "text": "Early on the long arc of innovation\n\n\n\nLong Arc of Innovation\n\n\nWhile the hype it peaking, it’s still early days for the technology. Today’s tools are like black and white TV in the 1960s and the future will bring tools equivalent to OLED 4k TVs. In the next few months already, we’ll see better models thanks to:\n\nLarger context windows enable models to take more information into account: GPT-4 supports up to 32k tokens, whereas GPT-3.5 was limited to 4k\nPlugins and chains via ChatGPT plugins and the langchain library. These give models access to the browser, Wolfram Alpha and more\nLet models store context information and access data via LlamaIndex Integration into more developer tasks, such as pull requests via Github Copilot X\nAgents that recursively call GPT-4, see Auto-GPT"
  },
  {
    "objectID": "posts/twitter_collector/index.html",
    "href": "posts/twitter_collector/index.html",
    "title": "Twitter API data collector with Modal",
    "section": "",
    "text": "Twitter API data collector with Modal\nIn this article, I’ll show how to build a Twitter data collector in just 100 lines of code. Twitter data has many applications, from social science research to marketing analytics. I’ll focus on the technical aspects of building a Twitter data collector.\nNote: As of 2023, Twitter has [deprecated] free access to API that this article uses. The code will need to be updated to use the new, paid API.\nBy the end of this article, we’ll have a fully automated Twitter data collector that runs in the cloud. It will fetch new tweets that mention a keyword, and save them to an AWS S3 bucket as a JSON file. It’ll run every 15 minutes.\nTo run the Twitter collector for yourself, please follow the instructions in the readme of the Github repository. The code is written in Python and uses the Modal framework to automate the deployment and scheduling."
  },
  {
    "objectID": "posts/twitter_collector/index.html#getting-data-from-the-twitter-api",
    "href": "posts/twitter_collector/index.html#getting-data-from-the-twitter-api",
    "title": "Twitter API data collector with Modal",
    "section": "Getting data from the Twitter API",
    "text": "Getting data from the Twitter API\nThe twitter Python package is an easy way to fetch data from the Twitter API. To get started, you need a Twitter developer account and API access keys. The developer account is free and you can create one here: https://developer.twitter.com/en.\nOnce you have the API keys, save them as environment variables. This is much safer than placing them directly into the code.\nHere’s a function that uses the twitter package to fetch tweets that mention a keyword:\nimport twitter\nimport os\n\ndef get_tweets(term: str, count: int, since_id: str = None) -&gt; list[dict]:\n    # Authenticate with Twitter API\n    api = twitter.Api(\n        consumer_key=os.environ[\"TWITTER_CONSUMER_KEY\"],\n        consumer_secret=os.environ[\"TWITTER_CONSUMER_SECRET\"],\n        access_token_key=os.environ[\"TWITTER_ACCESS_TOKEN\"],\n        access_token_secret=os.environ[\"TWITTER_ACCESS_SECRET\"],\n    )\n\n    # Fetch tweets that mention the term\n    tweets=api.GetSearch(\n        term=term,\n        count=count,\n        since_id=since_id,\n        lang=\"en\", # adjust to fetch tweets in other languages\n        result_type=\"recent\",\n    )\n\n    # Turn tweets object into a list of dictionaries\n    tweets_dict_list = [t.AsDict() for t in tweets]\n    return tweets_dict_list\nTo optimally use Twitter’s API limits, we want to only fetch tweets that we don’t have yet. That is done using the since_id parameter. The since_id is the id of the last tweet that we fetched. We can save this id to a file, and use it as the since_id parameter in the next call to get_tweets().\nIn addition to short term limits, the Twitter API caps data collection to 500k Tweets per month with Essential access and 2m Tweets per month with Elevated access."
  },
  {
    "objectID": "posts/twitter_collector/index.html#saving-twitter-data-to-s3",
    "href": "posts/twitter_collector/index.html#saving-twitter-data-to-s3",
    "title": "Twitter API data collector with Modal",
    "section": "Saving Twitter data to S3",
    "text": "Saving Twitter data to S3\nFor a long term project, data should be saved to secure cloud storage, such as AWS S3. From there, it could be analyzed using a data lake engine like AWS Athena, or loaded into a data warehouse.\nHere’s a function to save the tweets from a call to get_tweets() to an S3 bucket:\nimport boto3\nimport json\n\ndef save_tweets(filename: str, tweets: list[dict]):\n    # Save JSON to S3\n    s3 = boto3.client(\"s3\") # requires AWS credentials\n    s3.put_object(\n        Bucket=os.environ[\"S3_BUCKET\"],\n        Key=filename,\n        Body=json.dumps(tweets),\n    )\n\n    print(f\"Saved {len(tweets)} tweets to {filename} on S3\")\nOf course you could also substitute any other blob storage, such as Azure Blob Storage or Google Cloud Storage.\n\nS3 storage costs\nOver time, the S3 bucket will fill with JSON files. Each file will contain a list of tweets that mention a keyword. A JSON file containing 100 tweets is about 300 kB. If we assume that we fetch 100 tweets every 15 minutes for a keyword, we’ll have about 29 mB of data per day. That’s about 1 GB per month, per keyword. Zipping the files will reduce the size by about 85%, but it will make them a bit harder to work with.\nThe AWS free tier offers 5 GB of storage per month. After that, you’ll need to pay for the storage. In addition, there will be a charge for the number of PUT requests to S3. Each keyword will generate about 3,000 PUT requests per month, which amounts to $0.015 per month. The free tier allows 2,000 PUT requests per month."
  },
  {
    "objectID": "posts/twitter_collector/index.html#managing-a-panel-of-keywords",
    "href": "posts/twitter_collector/index.html#managing-a-panel-of-keywords",
    "title": "Twitter API data collector with Modal",
    "section": "Managing a panel of keywords",
    "text": "Managing a panel of keywords\nHow do we tell our app which terms to search for? We could hard code them into the app, but that would be a pain to maintain. Instead, we’ll save the terms to a JSON file in S3. The file will look like this:\n[\n    {\n        \"term\": \"python\",\n        \"since_id\": \"0\",\n        \"timestamp_last_search\": \"2021-01-01 00:00:00\"\n    },\n    {\n        \"term\": \"data science\",\n        \"since_id\": \"0\",\n        \"timestamp_last_search\": \"2021-01-01 00:00:00\"\n    }\n]\nThe since_id is the id of the last tweet that we fetched. Initially, it’s set to 0 so that we fetch all tweets. The timestamp_last_search is the last time that we searched for tweets that mention this term. We’ll use this to prioritize terms that haven’t been searched for recently.\nIn each run of the app, we’ll fetch the terms from S3, and save them back to S3 after we’re done. Here’s a function to fetch the terms from S3:\ndef get_terms() -&gt; list[dict]:\n    s3 = boto3.client(\"s3\")\n    terms = json.loads(\n        s3.get_object(\n            Bucket=os.environ[\"S3_BUCKET\"],\n            Key=\"terms.json\"\n        )[\"Body\"].read()\n    )\n\n    # Prioritize terms that have not been searched for recently\n    terms = sorted(terms, key=lambda t: (t[\"timestamp_last_search\"], t[\"since_id\"]))\n    return terms\nAfter fetching tweets, we update the terms.json file with the since_id of the last tweet and upload it to S3.\nfrom datetime import datetime\n\ndef save_terms(terms: list[dict]) -&gt; None:\n    s3 = boto3.client(\"s3\")\n    s3.put_object(\n        Bucket=os.environ[\"S3_BUCKET\"],\n        Key=\"terms.json\",\n        Body=json.dumps(terms),\n    )\n    print(\"Updated terms.json on S3\")\n\nfor term in terms:\n    get_tweets(term[\"term\"], 100)\n    save_tweets(\"tweets.json\", tweets)\n\n    term[\"since_id\"] = tweets[-1][\"id\"]\n    term[\"timestamp_last_search\"] = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"\n    save_terms(terms)\nPlease note that this solution is not thread safe. If multiple instances of the app are running, they could overwrite each other’s changes to terms.json. This is a problem that could be solved by using a database, such as AWS DynamoDB."
  },
  {
    "objectID": "posts/twitter_collector/index.html#automating-in-the-cloud-using-modal",
    "href": "posts/twitter_collector/index.html#automating-in-the-cloud-using-modal",
    "title": "Twitter API data collector with Modal",
    "section": "Automating in the cloud using Modal",
    "text": "Automating in the cloud using Modal\nModal is a Python framework for automating the deployment and scheduling of Python functions. It’s designed to be simple and easy to use. I found it easier and more powerful than AWS Lambda. They offer a $30 monthly free tier.\nModal takes Python code that is decorated with @stub.function() and deploys it to the cloud. It also handles the scheduling of the functions. The code is run in a Docker container, so you can use any Python package you want. Modal also provides a distributed dictionary, called stub.info in the code below that can be used to global variables. This is useful for storing the S3 bucket name, for example.\nimport modal\n\nstub = modal.Stub(\n    image=modal.Image.debian_slim().pip_install([\"boto3\", \"python-twitter\"])\n)\nHere we instruct Modal to build a Docker image that contains the boto3 and python-twitter packages. This image will be used to run the code in the cloud.\n\nScheduling\nThe Twitter API imposes a rate limit that resets every 15 minutes. So we’ll wrap the loop we previously wrote into a main() function to run every 15 minutes. This is done using the schedule argument in the @stub.function() decorator.\nfrom datetime import datetime\n\n@stub.function(schedule=modal.Period(minutes=15))\ndef main():\n    terms = get_terms.call()\n\n    print(f\"Terms to search: {', '.join([t['term'] for t in terms])}\")\n\n    for term in terms:\n        print(f\"Searching for term: {term['term']}\")\n\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H-%M-%S\")\n        filename = f\"{timestamp} {term['term']}.json\".replace(\" \", \"_\")\n\n        try:\n            tweets = get_tweets.call(term[\"term\"], 100)  # maximum allowed\n        except Exception as e:\n            print(e)\n            print(\"Could not get tweets. Saving tweets collected so far.\")\n            break\n\n        since_id = save_tweets.call(filename, tweets)  # returns since_id\n\n        # Update values in terms\n        term[\"since_id\"] = since_id\n        term[\"timestamp_last_search\"] = timestamp\n\n    save_terms.call(terms)\nNote that I’ve used the call() method to call the functions that we defined earlier. This is because we want them to run as Modal stubs in the cloud. The previous functions need slight modifications to become stubs. For example, the get_tweets function needs to be decorated like so:\n@stub.function(secret=modal.Secret.from_name(\"twitter-api\"))\ndef get_tweets()\n    ...\nThis lets Modal recognize it as a runnable function and also tells it to supply a secret variable to it. I’ve defined the secret variable in the Modal dashboard. The twitter-api secret variable contains the Twitter API keys and tokens. The aws-s3-access secret variable contains the AWS access key and secret key for an IAM user that has access to the S3 bucket.\n\n\nRunning and deploying\nTo run the app on Modal, we need to wrap the main() function in a if __name__ == \"__main__\" block. This lets us run the function from the command line. We also need to call stub.run() to start the stubs.\nif __name__ == \"__main__\":\n    with stub.run():\n        main()\nTo run this, use python app.py. The execution will happen on Modal. You can see the logs in the Modal dashboard. To schedule it, run modal deploy app.py. Modal automatically logs the runs and informs you if there are any errors.\n\n\nModal monitoring & costs\nModal charges CPU and memory by the second and only charges for what’s actually used. See their pricing. Cron jobs, monitoring, logging and custom Docker images are free.\n\n\n\nMonitoring\n\n\nThe monitoring dashboard shows the scheduled executions, the CPU and memory usage, and the logs. As shown in the screenshot, I encountered a few errors while testing the app. The logs helped me debug the issues. The app never used even 0.05 CPU cores at a time and requires less than 10 MB of memory. Thanks to Modal’s pricing model, this app will cost less than $1 per month to run.\nIn addition to monitoring via Modal, you may wish to sign to updates from the Twitter API status page. This will inform you of any issues with the API."
  },
  {
    "objectID": "posts/twitter_collector/index.html#conclusion",
    "href": "posts/twitter_collector/index.html#conclusion",
    "title": "Twitter API data collector with Modal",
    "section": "Conclusion",
    "text": "Conclusion\nIn this post, we built a Python app that fetches tweets from Twitter and saves them to S3. We used Modal to deploy and schedule the app in the cloud, complete with monitoring and logging. The next step is to analyze the tweets. I’ll write about that in a future post.\nIf you wish to run this app yourself, you can clone the repo from GitHub and follow the install instructions in the README.\nPhoto by Joshua Sortino on Unsplash"
  },
  {
    "objectID": "posts/dataframes/index.html",
    "href": "posts/dataframes/index.html",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "",
    "text": "I’m a long time R user and lately I’ve seen more and more signals that it’s worth investing into Python. I use it for NLP with spaCy and to build functions on AWS Lambda. Further, there are many more data API libraries and machine learning libraries for Python than for R.\nAdopting Python means making choices on which libraries to invest time into learning. Manipulating data frames is one of the most common data science activities, so choosing the right library for it is key.\nMichael Chow, developer of siuba, a Python port of dplyr on top of pandas wrote describes the situation well:\nThe higher-level libraries he mentions come with a problem : There’s no universal standard.\nIn a discussion of the polars library on Hacker News the user “civilized” put the dplyr user perspective more bluntly:\nI’m more willing to compromise though, so here’s a comparison of the strongest contenders."
  },
  {
    "objectID": "posts/dataframes/index.html#the-contenders",
    "href": "posts/dataframes/index.html#the-contenders",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "The contenders",
    "text": "The contenders\nThe database-like ops benchmark on H2Oai is a helpful performance comparison.\nI’m considering these libraries:\n\nPandas: The most commonly used library and the one with the most tutorials and Stack Overflow answers available.\nsiuba: A port of dplyr to Python, built on top of pandas. Not in the benchmark. Performance probably similar to pandas or worse due to translation.\nPolars: The fastest library available. According to the benchmark, it runs 3-10x faster than Pandas.\nDuckdb: Use an in-memory OLAP database instead of a dataframe and write SQL. In R, this can also be queried via dbplyr.\nibis. Backend-agnostic wrapper for pandas and SQL engines.\n\nThere are more options. I excluded the others for these reasons:\n\nSlower than polars and not with a readability focus (dask, Arrow, Modin, pydatatable)\nRequires or is optmized for running on a remote server (Spark, ClickHouse and most other SQL databases).\nNot meant for OLAP (sqlite)\nNot in Python (DataFrames.jl)\nMeant for GPU (cuDF)"
  },
  {
    "objectID": "posts/dataframes/index.html#github-stars-as-a-proxy-for-popularity",
    "href": "posts/dataframes/index.html#github-stars-as-a-proxy-for-popularity",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "Github stars as a proxy for popularity",
    "text": "Github stars as a proxy for popularity\nThe benchmark provides a comparison of performance, but another important factor is popularity and maturity. A more mature library has a more stable API, better test coverage and there is more help available online, such as on StackOverflow. One way to measure popularity is the number of stars that the package repository has on Github.\n\nlibrary(ggplot2)\nlibs &lt;- data.frame(\n    library = c(\"pandas\", \"siuba\", \"polars\", \"duckdb\", \"dplyr\", \"data.table\", \"pydatatable\", \"dtplyr\", \"tidytable\", \"ibis\"),\n    language = c(\"Python\", \"Python\", \"Python\", \"SQL\", \"R\", \"R\", \"Python\", \"R\", \"R\", \"Python\"),\n    stars = c(32100, 732, 3900, 4100, 3900, 2900, 1400, 542, 285, 1600)\n)\n\nggplot(libs, aes(x = reorder(library, -stars), y = stars, fill = language)) +\n    geom_col() +\n    labs(\n        title = \"Pandas is by far the most popular choice\",\n        subtitle = \"Comparison of Github stars on 2021-12-25\",\n        fill = \"Language\",\n        x = \"Library\",\n        y = \"Github stars\"\n    )\n\n\n\n\nGithub stars are not a perfect proxy. For instance, dplyr is more mature than its star count suggests. Comparing the completeness of the documentation and tutorials for dplyr and polars reveals that it’s a day and night difference.\nWith the quantitative comparison out of the way, here’s a qualitative comparison of the Python packages. I’m speaking of my personal opinion of these packages - not a general comparison. My reference is my current use of dplyr in R. When I need more performance, I use tidytable to get most of the speed of data.table with the grammar of dplyr and eager evaluation. Another alternative is dtplyr, which translates dplyr to data.table with lazy evaluation. I also use dbplyr, which translates dplyr to SQL.\nI’ll compare the libraries by running a data transformation pipeline involving import from CSV, mutate, filter, sort, join, group by and summarize. I’ll use the nycflights13 dataset, which is featured in Hadley Wickham’s R for Data Science."
  },
  {
    "objectID": "posts/dataframes/index.html#dplyr-reference-in-r",
    "href": "posts/dataframes/index.html#dplyr-reference-in-r",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "dplyr: Reference in R",
    "text": "dplyr: Reference in R\nLet’s start with a reference implementation in dplyr. The dataset is available as a package, so I skip the CSV import.\n\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(nycflights13)\nlibrary(reactable)\n\n# Take a look at the tables\nreactable(head(flights, 10))\n\n\n\n\n\nreactable(head(airlines, 10))\n\n\n\n\n\n\nThe flights tables has 336776 rows, one for each flight of an airplane. The airlines table has 16 rows, one for each airline mapping the full name of the company to a code.\nLet’s find the airline with the highest arrival delays in January 2013.\n\nflights |&gt;\n    filter(year == 2013, month == 1, !is.na(arr_delay)) |&gt;\n    mutate(arr_delay = replace(arr_delay, arr_delay &lt; 0, 0)) |&gt;\n    left_join(airlines, by = \"carrier\") |&gt;\n    group_by(airline = name) |&gt;\n    summarise(flights = n(), mean_delay = mean(arr_delay)) |&gt;\n    arrange(desc(mean_delay))\n\n# A tibble: 16 × 3\n   airline                     flights mean_delay\n   &lt;chr&gt;                         &lt;int&gt;      &lt;dbl&gt;\n 1 SkyWest Airlines Inc.             1     107   \n 2 Hawaiian Airlines Inc.           31      48.8 \n 3 ExpressJet Airlines Inc.       3964      29.6 \n 4 Frontier Airlines Inc.           59      23.9 \n 5 Mesa Airlines Inc.               39      20.4 \n 6 Endeavor Air Inc.              1480      19.3 \n 7 Alaska Airlines Inc.             62      17.6 \n 8 Envoy Air                      2203      14.3 \n 9 Southwest Airlines Co.          985      13.0 \n10 JetBlue Airways                4413      12.9 \n11 United Air Lines Inc.          4590      11.9 \n12 American Airlines Inc.         2724      11.0 \n13 AirTran Airways Corporation     324       9.95\n14 US Airways Inc.                1554       9.11\n15 Delta Air Lines Inc.           3655       8.07\n16 Virgin America                  314       3.17\n\n\nSome values in arr_delay are negative, indicating that the flight was faster than expected. I replaced these values with 0 because I don’t want them to cancel out delays of other flights. I joined to the airlines table to get the full names of the airlines.\nI export the flights and airlines tables to CSV to hand them over to Python.\n\n# Write to temporary files\nflights_path &lt;- tempfile(fileext = \".csv\")\nairlines_path &lt;- tempfile(fileext = \".csv\")\n\ndata.table::fwrite(flights, flights_path, row.names = FALSE)\ndata.table::fwrite(airlines, airlines_path, row.names = FALSE)\n\nTo access the file from Python, the path is handed over:\n\n# Hand over the path from R\nflights_path = r[\"flights_path\"]\nairlines_path = r[\"airlines_path\"]\n\nFor more details on how this works with the reticulate package, check this documentation."
  },
  {
    "objectID": "posts/dataframes/index.html#pandas-most-popular",
    "href": "posts/dataframes/index.html#pandas-most-popular",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "Pandas: Most popular",
    "text": "Pandas: Most popular\nThe following sections follow a pattern: read in from CSV, then build a query.\n\nimport pandas as pd\n\n# Import from CSV\nflights_pd = pd.read_csv(flights_path)\nairlines_pd = pd.read_csv(airlines_path)\n\npandas.read_csv reads the header and conveniently infers the column types.\n\n(\n    flights_pd.query(\"year == 2013 & month == 1 & arr_delay.notnull()\")\n    .assign(arr_delay=flights_pd.arr_delay.clip(lower=0))\n    .merge(airlines_pd, how=\"left\", on=\"carrier\")\n    .rename(columns={\"name\": \"airline\"})\n    .groupby(\"airline\")\n    .agg(flights=(\"airline\", \"count\"), mean_delay=(\"arr_delay\", \"mean\"))\n    .sort_values(by=\"mean_delay\", ascending=False)\n)\n\n                             flights  mean_delay\nairline                                         \nSkyWest Airlines Inc.              1  107.000000\nHawaiian Airlines Inc.            31   48.774194\nExpressJet Airlines Inc.        3964   29.642785\nFrontier Airlines Inc.            59   23.881356\nMesa Airlines Inc.                39   20.410256\nEndeavor Air Inc.               1480   19.321622\nAlaska Airlines Inc.              62   17.645161\nEnvoy Air                       2203   14.303677\nSouthwest Airlines Co.           985   12.964467\nJetBlue Airways                 4413   12.919329\nUnited Air Lines Inc.           4590   11.851852\nAmerican Airlines Inc.          2724   10.953377\nAirTran Airways Corporation      324    9.953704\nUS Airways Inc.                 1554    9.111326\nDelta Air Lines Inc.            3655    8.070315\nVirgin America                   314    3.165605\n\n\nI chose to use the pipeline syntax from pandas - another option is to modify the dataset in place. That has a lower memory footprint, but can’t be run repeatedly for the same result, such as in interactive use in a notebook.\nHere, the query() function is slightly awkward with the long string argument. The groupby doesn’t allow renaming on the fly like dplyr, though I don’t consider that a real drawback. Perhaps it’s clearer to rename explicitly anyway.\nPandas has the widest API, offering hundreds of functions for every conceivable manipulation. The clip function used here is one such example. One difference to dplyr is that pandas uses its own methods .mean(), rather than using external ones such as base::mean(). That means using custom functions instead carries a performance penalty.\nAs we’ll see later, pandas is the backend for siuba and ibis, which boil down to pandas code.\nOne difference to all other discussed solutions is that pandas uses a row index. Base R also has this with row names, but the tidyverse and tibbles have largely removed them from common use. I never missed row names. At the times I had to work with them in pandas they were more confusing than helpful. The documentation of polars puts it more bluntly:\n\nNo index. They are not needed. Not having them makes things easier. Convince me otherwise\n\nThat’s quite passive aggressive, but I do agree and wish pandas didn’t have it."
  },
  {
    "objectID": "posts/dataframes/index.html#siuba-dplyr-in-python",
    "href": "posts/dataframes/index.html#siuba-dplyr-in-python",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "siuba: dplyr in Python",
    "text": "siuba: dplyr in Python\n\nimport siuba as si\n\n# Import from CSV\nflights_si = pd.read_csv(r[\"flights_path\"])\nairlines_si = pd.read_csv(r[\"airlines_path\"])\n\nAs siuba is just an alternative way of writing some pandas commands, we read the data just like in the pandas implementation.\n\n(\n    flights_si\n    &gt;&gt; si.filter(si._.year == 2013, si._.month == 1, si._.arr_delay.notnull())\n    &gt;&gt; si.mutate(arr_delay=si._.arr_delay.clip(lower=0))\n    &gt;&gt; si.left_join(si._, airlines_si, on=\"carrier\")\n    &gt;&gt; si.rename(airline=si._.name)\n    &gt;&gt; si.group_by(si._.airline)\n    &gt;&gt; si.summarize(flights=si._.airline.count(), mean_delay=si._.arr_delay.mean())\n    &gt;&gt; si.arrange(-si._.mean_delay)\n)\n\n                        airline  flights  mean_delay\n11        SkyWest Airlines Inc.        1  107.000000\n8        Hawaiian Airlines Inc.       31   48.774194\n6      ExpressJet Airlines Inc.     3964   29.642785\n7        Frontier Airlines Inc.       59   23.881356\n10           Mesa Airlines Inc.       39   20.410256\n4             Endeavor Air Inc.     1480   19.321622\n1          Alaska Airlines Inc.       62   17.645161\n5                     Envoy Air     2203   14.303677\n12       Southwest Airlines Co.      985   12.964467\n9               JetBlue Airways     4413   12.919329\n14        United Air Lines Inc.     4590   11.851852\n2        American Airlines Inc.     2724   10.953377\n0   AirTran Airways Corporation      324    9.953704\n13              US Airways Inc.     1554    9.111326\n3          Delta Air Lines Inc.     3655    8.070315\n15               Virgin America      314    3.165605\n\n\nI found siuba the easiest to work with. Once I understood the _ placeholder for a table of data, I could write it almost as fast as dplyr. Out of all the ways to refer to a column in a data frame, I found it to be the most convenient, because it doesn’t require me to spell out the name of the data frame over and over. While not as elegant as dplyr’s tidy evaluation (discussed at the end of the article), it avoids the ambivalence in dplyr where it can be unclear whether a name refers to a column or an outside object.\nIt’s always possible to drop into pandas, such as for the aggregation functions which use the mean() and count() methods of the pandas series. The &gt;&gt; is an easy replacement for the %&gt;% magrittr pipe or |&gt; base pipe in R.\nThe author advertises siuba like this (from the docs):\n\nSiuba is a library for quick, scrappy data analysis in Python. It is a port of dplyr, tidyr, and other R Tidyverse libraries.\n\nA way for dplyr users to quickly hack away at data analysis in Python, but not meant for unsupervised production use."
  },
  {
    "objectID": "posts/dataframes/index.html#polars-fastest",
    "href": "posts/dataframes/index.html#polars-fastest",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "Polars: Fastest",
    "text": "Polars: Fastest\nPolars is written in Rust and also offers a Python API. It comes in two flavors: eager and lazy. Lazy evaluation is similar to how dbplyr and dtplyr work: until asked, nothing is evaluated. This enables performance gains by reordering the commands being executed. But it’s a little less convenient for interactive analysis. I’ll use the eager API here.\n\nimport polars as pl\n\n# Import from CSV\nflights_pl = pl.read_csv(flights_path)\nairlines_pl = pl.read_csv(airlines_path)\n\n\n(\n    flights_pl.filter((pl.col(\"year\") == 2013) & (pl.col(\"month\") == 1))\n    .drop_nulls(\"arr_delay\")\n    .join(airlines_pl, on=\"carrier\", how=\"left\")\n    .with_columns(\n        [\n            pl.when(pl.col(\"arr_delay\") &gt; 0)\n            .then(pl.col(\"arr_delay\"))\n            .otherwise(0)\n            .alias(\"arr_delay\"),\n            pl.col(\"name\").alias(\"airline\"),\n        ]\n    )\n    .groupby(\"airline\")\n    .agg(\n        [pl.count(\"airline\").alias(\"flights\"), pl.mean(\"arr_delay\").alias(\"mean_delay\")]\n    )\n    .sort(\"mean_delay\", descending=True)\n)\n\n\nshape: (16, 3)\n\n\n\nairline\nflights\nmean_delay\n\n\nstr\nu32\nf64\n\n\n\n\n\"SkyWest Airlin…\n1\n107.0\n\n\n\"Hawaiian Airli…\n31\n48.774194\n\n\n\"ExpressJet Air…\n3964\n29.642785\n\n\n\"Frontier Airli…\n59\n23.881356\n\n\n\"Mesa Airlines …\n39\n20.410256\n\n\n\"Endeavor Air I…\n1480\n19.321622\n\n\n\"Alaska Airline…\n62\n17.645161\n\n\n\"Envoy Air\"\n2203\n14.303677\n\n\n\"Southwest Airl…\n985\n12.964467\n\n\n\"JetBlue Airway…\n4413\n12.919329\n\n\n\"United Air Lin…\n4590\n11.851852\n\n\n\"American Airli…\n2724\n10.953377\n\n\n\"AirTran Airway…\n324\n9.953704\n\n\n\"US Airways Inc…\n1554\n9.111326\n\n\n\"Delta Air Line…\n3655\n8.070315\n\n\n\"Virgin America…\n314\n3.165605\n\n\n\n\n\n\nThe API is leaner than pandas, requiring to memorize fewer functions and patterns. Though this can also be seen as less feature-complete. Pandas, for example has a dedicated clip function.\nThere isn’t nearly as much help available for problems with polars as for with pandas. While the documentation is good, it can’t answer every question and lots of trial and error is needed.\nA comparison of polars and pandas is available in the polars documentation."
  },
  {
    "objectID": "posts/dataframes/index.html#duckdb-highly-compatible-and-easy-for-sql-users",
    "href": "posts/dataframes/index.html#duckdb-highly-compatible-and-easy-for-sql-users",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "DuckDB: Highly compatible and easy for SQL users",
    "text": "DuckDB: Highly compatible and easy for SQL users\n\nimport duckdb\n\ncon_duckdb = duckdb.connect(database=\":memory:\")\n\n# Import from CSV\ncon_duckdb.execute(\n    \"CREATE TABLE 'flights' AS \"\n    f\"SELECT * FROM read_csv_auto('{flights_path}', header = True);\"\n    \"CREATE TABLE 'airlines' AS \"\n    f\"SELECT * FROM read_csv_auto('{airlines_path}', header = True);\"\n)\n\n&lt;duckdb.duckdb.DuckDBPyConnection object at 0x17d2497f0&gt;\n\n\nDuckDB’s read_csv_auto() works just like the csv readers in Python.\n\ncon_duckdb.execute(\n    \"WITH flights_clipped AS ( \"\n    \"SELECT carrier, CASE WHEN arr_delay &gt; 0 THEN arr_delay ELSE 0 END AS arr_delay \"\n    \"FROM flights \"\n    \"WHERE year = 2013 AND month = 1 AND arr_delay IS NOT NULL\"\n    \")\"\n    \"SELECT name AS airline, COUNT(*) AS flights, AVG(arr_delay) AS mean_delay \"\n    \"FROM flights_clipped \"\n    \"LEFT JOIN airlines ON flights_clipped.carrier = airlines.carrier \"\n    \"GROUP BY name \"\n    \"ORDER BY mean_delay DESC \"\n).fetchdf()\n\n                        airline  flights  mean_delay\n0         SkyWest Airlines Inc.        1  107.000000\n1        Hawaiian Airlines Inc.       31   48.774194\n2      ExpressJet Airlines Inc.     3964   29.642785\n3        Frontier Airlines Inc.       59   23.881356\n4            Mesa Airlines Inc.       39   20.410256\n5             Endeavor Air Inc.     1480   19.321622\n6          Alaska Airlines Inc.       62   17.645161\n7                     Envoy Air     2203   14.303677\n8        Southwest Airlines Co.      985   12.964467\n9               JetBlue Airways     4413   12.919329\n10        United Air Lines Inc.     4590   11.851852\n11       American Airlines Inc.     2724   10.953377\n12  AirTran Airways Corporation      324    9.953704\n13              US Airways Inc.     1554    9.111326\n14         Delta Air Lines Inc.     3655    8.070315\n15               Virgin America      314    3.165605\n\n\nThe performance is closer to polars than to pandas. A big plus is the ability to handle larger than memory data.\nDuckDB can also operate directly on a pandas dataframe. The SQL code is portable to R, C, C++, Java and other programming languages the duckdb has APIs. It’s also portable when the logic is taken to a DB like Postgres, or Clickhouse, or is ported to an ETL framework like DBT.\nThis stands in contrast to polars and pandas code, which has to be rewritten from scratch. It also means that the skill gained in manipulating SQL translates well to other situations. SQL has been around for more than 50 years - learning SQL is future-proofing a career.\nWhile these are big plusses, duckdb isn’t so convenient for interactive data exploration. SQL isn’t as composeable. Composing SQL queries requires many common table expressions (CTEs, WITH x AS (SELECT ...)). Reusing them for other queries is not as easy as with Python. SQL is typically less expressive than Python. It lacks shorthands and it’s awkward when there are many columns. It’s also harder to write custom functions in SQL than in R or Python. This is the motivation for using libraries like pandas and dplyr. But SQL can actually do a surprising amount of things, as database expert Haki Benita explained in a detailed article.\nOr in short, from the documentation of ibis:\n\nSQL is widely used and very convenient when writing simple queries. But as the complexity of operations grow, SQL can become very difficult to deal with.\n\nThen, there’s the issue of how to actually write the SQL code. Writing strings rather than actual Python is awkward and many editors don’t provide syntax highlighting within the strings (Jetbrains editors like PyCharm and DataSpell do). The other option is writing .sql that have placeholders for parameters. That’s cleaner and allows using a linter, but is inconvenient for interactive use.\nSQL is inherently lazily executed, because the query planner needs to take the whole query into account before starting computation. This enables performance gains. For interactive use, lazy evaluation is less convenient, because one can’t see the intermediate results at each step. Speed of iteration is critical: the faster one can iterate, the more hypotheses about the data can be tested.\nThere is a programmatic way to construct queries for duckdb, designed to provide a dbplyr alternative in Python. Unfortunately its documentation is sparse.\nUsing duckdb without pandas doesn’t seem feasible for exploratory data analysis, because graphing packages like seaborn and plotly expect a pandas data frame or similar as an input."
  },
  {
    "objectID": "posts/dataframes/index.html#ibis-lingua-franca-in-python",
    "href": "posts/dataframes/index.html#ibis-lingua-franca-in-python",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "ibis: Lingua franca in Python",
    "text": "ibis: Lingua franca in Python\nThe goal of ibis is to provide a universal language for working with data frames in Python, regardless of the backend that is used. It’s tagline is: Write your analytics code once, run in everywhere. This is similar to how dplyr can use SQL as a backend with dbplyr and data.table with dtplyr.\nAmong others, Ibis supports pandas, PostgreSQL and SQLite as backends. Unfortunately duckdb is not an available backend, because the authors of duckdb have decided against building on ibis.\nThe ibis project aims to bridge the gap between the needs of interactive data analysis and the capabilities of SQL, which I have detailed in the previous section on duckdb.\n\n\n\n\n\n\nNote\n\n\n\nUPDATE October 2023\n\nDuckdb is now a supported backend (along with many more). So performance is going to be very similar to duckdb.\nDirectly load/save data\njoin(), clip(), and case() are well-supported\nIbis is much more popular and now very actively maintained. There are more examples, better documentation, and community. Still definitely less than pandas, but perhaps comparable to polars.\n\nThanks to NickCrews for providing this update, including the following code example.\n\n\nFor the test drive, I’ll use the duckdb backend, meaning that the ibis code is translated to duckdb operations, similar to how siuba is translated to pandas. This gives ibis the blazing speed of duckdb.\n\nimport ibis\nfrom ibis import _\n\nflights_ib_csv = pd.read_csv(flights_path)\nairlines_ib_csv = pd.read_csv(airlines_path)\n\nibis.options.interactive = True\n\nflights_ib = ibis.read_csv(flights_path)\nairlines_ib = ibis.read_csv(airlines_path)\nflights_ib\n\n┏━━━━━━━┳━━━━━━━┳━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━┳━━━┓\n┃ year  ┃ month ┃ day   ┃ dep_time ┃ sched_dep_time ┃ dep_delay ┃ arr_time ┃ … ┃\n┡━━━━━━━╇━━━━━━━╇━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━╇━━━┩\n│ int64 │ int64 │ int64 │ int64    │ int64          │ int64     │ int64    │ … │\n├───────┼───────┼───────┼──────────┼────────────────┼───────────┼──────────┼───┤\n│  2013 │     1 │     1 │      517 │            515 │         2 │      830 │ … │\n│  2013 │     1 │     1 │      533 │            529 │         4 │      850 │ … │\n│  2013 │     1 │     1 │      542 │            540 │         2 │      923 │ … │\n│  2013 │     1 │     1 │      544 │            545 │        -1 │     1004 │ … │\n│  2013 │     1 │     1 │      554 │            600 │        -6 │      812 │ … │\n│  2013 │     1 │     1 │      554 │            558 │        -4 │      740 │ … │\n│  2013 │     1 │     1 │      555 │            600 │        -5 │      913 │ … │\n│  2013 │     1 │     1 │      557 │            600 │        -3 │      709 │ … │\n│  2013 │     1 │     1 │      557 │            600 │        -3 │      838 │ … │\n│  2013 │     1 │     1 │      558 │            600 │        -2 │      753 │ … │\n│     … │     … │     … │        … │              … │         … │        … │ … │\n└───────┴───────┴───────┴──────────┴────────────────┴───────────┴──────────┴───┘\n\n\nNon-interactive ibis means that queries are evaluated lazily.\n\n(\n    flights_ib.filter(\n        [\n            _.year == 2013,\n            _.month == 1,\n            _.arr_delay.notnull(),\n        ]\n    )\n    .join(airlines_ib, \"carrier\", how=\"left\")\n    .select(arr_delay=_.arr_delay.clip(lower=0), airline=_.name)\n    .group_by(\"airline\")\n    .agg(flights=_.count(), mean_delay=_.arr_delay.mean())\n    .order_by(_.mean_delay.desc())\n)\n\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━┓\n┃ airline                  ┃ flights ┃ mean_delay ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━┩\n│ string                   │ int64   │ float64    │\n├──────────────────────────┼─────────┼────────────┤\n│ SkyWest Airlines Inc.    │       1 │ 107.000000 │\n│ Hawaiian Airlines Inc.   │      31 │  48.774194 │\n│ ExpressJet Airlines Inc. │    3964 │  29.642785 │\n│ Frontier Airlines Inc.   │      59 │  23.881356 │\n│ Mesa Airlines Inc.       │      39 │  20.410256 │\n│ Endeavor Air Inc.        │    1480 │  19.321622 │\n│ Alaska Airlines Inc.     │      62 │  17.645161 │\n│ Envoy Air                │    2203 │  14.303677 │\n│ Southwest Airlines Co.   │     985 │  12.964467 │\n│ JetBlue Airways          │    4413 │  12.919329 │\n│ …                        │       … │          … │\n└──────────────────────────┴─────────┴────────────┘\n\n\nThe syntax looks quite similar to dplyr and the versatility of interchangeable backends is remarkable. In the first version of this article, ibis was lacking in documentation and had some rough edges in the API, but these were improved in the meantime."
  },
  {
    "objectID": "posts/dataframes/index.html#conclusion",
    "href": "posts/dataframes/index.html#conclusion",
    "title": "Data frame wars: Choosing a Python dataframe library as a dplyr user",
    "section": "Conclusion",
    "text": "Conclusion\nIt’s not a clear-cut choice. None of the options offer a syntax that is as convenient for interactive analysis as dplyr. siuba is the closest to it, but dplyr still has an edge with tidy evaluation, letting users refer to columns in a data frame by their names (colname) directly, without any wrappers. But I’ve also seen it be confusing for newbies to R that mix it up with base R’s syntax. It’s also harder to program with, where it’s necessary to use operators like {{ }} and :=.\nMy appreciation for dplyr (and the closely associated tidyr) grew during this research. Not only is it a widely accepted standard like pandas, it can also be used as a translation layer for backends like SQL databases (including duckdb), data.table, and Spark. All while having the most elegant and flexible syntax available.\nPersonally, I’ll primarily leverage SQL and a OLAP database (such as Clickhouse or Snowflake) running on a server to do the heavy lifting. For steps that are better done locally, I’ll use pandas for maximum compatibility. I find the use of an index inconvenient, but there’s so much online help available on StackOverflow. Github Copilot also deserves a mention for making it easier to pick up. Other use cases can be very different, so I don’t mean to say that my way is the best. For instance, if the data is not already on a server, fast local processing with polars may be best.\nMost data science work happens in a team. Choosing a library that all team members are familiar with is critical for collaboration. That is typically SQL, pandas or dplyr. The performance gains from using a less common library like polars have to be weighed against the effort spent learning the syntax as well as the increased likelihood of bugs, when beginners write in a new syntax.\nRelated articles:\n\nPolars: the fastest DataFrame library you’ve never heard of\nWhat would it take to recreate dplyr in python?\nPandas has a hard job (and does it well)\ndplyr in Python? First impressions of the siuba module\nAn Overview of Python’s Datatable package\nDiscussion of DuckDB on Hacker News\nDiscussion of Polars on Hacker News\nPractical SQL for Data Analysis\n\nPhoto by Hunter Harritt on Unsplash"
  },
  {
    "objectID": "posts/yarn/index.html",
    "href": "posts/yarn/index.html",
    "title": "Tidy Tuesday: analyzing yarns with polars",
    "section": "",
    "text": "In this article, I’m taking the Python data frame library polars for a spin. Polars is a super fast alternative to pandas, implemented in Rust. It also has a leaner interface and doesn’t need an index column. To learn more about how it compares to other data frame libraries, see my article about data frames.\nI’m analyzing a dataset about yarns from the knitting website Ravelry. You can find the dataset on Github.\nIt lists 100,000 yarns, with information about the yarn’s name, brand, weight and rating by Ravelry users.\nFirst, let’s load the data and have a look at it. I load the data directly from the Github repository.\nimport urllib.request\nimport os\n\nfilename = \"yarn.csv\"\nif not os.path.exists(filename):\n    url = \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/6830f858fd0e87af47dfa1ecc7043b7c05f85e69/data/2022/2022-10-11/yarn.csv\"\n    urllib.request.urlretrieve(url, \"yarn.csv\")\nNow I have a CSV file on disk. I can load it into a polars DataFrame. Here, I’ve specified the column types manually, so polars doesn’t have to guess them.\nimport polars as pl\n\nyarn = pl.read_csv(\n    source=\"yarn.csv\",\n    has_header=True,\n    null_values=[\"NA\"],\n    ignore_errors=True,\n    dtypes={\n        \"discontinued\": pl.Boolean,\n        \"gauge_divisor\": pl.Int32,\n        \"grams\": pl.Int32,\n        \"id\": pl.Int32,\n        \"machine_washable\": pl.Boolean,\n        \"max_gauge\": pl.Float64,\n        \"min_gauge\": pl.Float64,\n        \"name\": pl.Utf8,\n        \"permalink\": pl.Utf8,\n        \"rating_average\": pl.Float64,\n        \"rating_count\": pl.Int32,\n        \"rating_total\": pl.Int32,\n        \"texture\": pl.Utf8,\n        \"thread_size\": pl.Utf8,\n        \"wpi\": pl.Int32,\n        \"yardage\": pl.Int32,\n        \"yarn_company_name\": pl.Utf8,\n        \"yarn_weight_crochet_gauge\": pl.Float64,\n        \"yarn_weight_id\": pl.Int32,\n        \"yarn_weight_knit_gauge\": pl.Float64,\n        \"yarn_weight_name\": pl.Utf8,\n        \"yarn_weight_ply\": pl.Int32,\n        \"yarn_weight_wpi\": pl.Int32,\n        \"texture_clean\": pl.Utf8,\n    },\n)\nyarn.head(10)\n\n\nshape: (10, 24)\n\n\n\ndiscontinued\ngauge_divisor\ngrams\nid\nmachine_washable\nmax_gauge\nmin_gauge\nname\npermalink\nrating_average\nrating_count\nrating_total\ntexture\nthread_size\nwpi\nyardage\nyarn_company_name\nyarn_weight_crochet_gauge\nyarn_weight_id\nyarn_weight_knit_gauge\nyarn_weight_name\nyarn_weight_ply\nyarn_weight_wpi\ntexture_clean\n\n\nbool\ni32\ni32\ni32\nbool\nf64\nf64\nstr\nstr\nf64\ni32\ni32\nstr\nstr\ni32\ni32\nstr\nf64\ni32\nf64\nstr\ni32\ni32\nstr\n\n\n\n\nfalse\n4\n198\n2059\ntrue\nnull\n17.0\n\"Super Saver So…\n\"red-heart-supe…\n3.58\n17616\n63069\n\"cable plied\"\nnull\nnull\n364\n\"Red Heart\"\nnull\n1\n18.0\n\"Aran\"\n10\n8\n\"cable plied\"\n\n\nfalse\n4\n170\n3330\ntrue\nnull\n18.0\n\"Simply Soft So…\n\"caron-simply-s…\n4.03\n19133\n77147\n\"plied\"\nnull\nnull\n315\n\"Caron\"\nnull\n1\n18.0\n\"Aran\"\n10\n8\n\"plied\"\n\n\nfalse\n4\n100\n523\nnull\n20.0\n18.0\n\"Cascade 220®\"\n\"cascade-yarns-…\n4.48\n21517\n96470\n\"plied\"\nnull\n9\n220\n\"Cascade Yarns …\nnull\n12\n20.0\n\"Worsted\"\n10\n9\n\"plied\"\n\n\nfalse\n4\n100\n5741\ntrue\nnull\n16.0\n\"Vanna's Choice…\n\"lion-brand-van…\n3.87\n13959\n54036\n\"plied\"\nnull\nnull\n170\n\"Lion Brand\"\nnull\n1\n18.0\n\"Aran\"\n10\n8\n\"plied\"\n\n\nfalse\n4\n100\n1666\nnull\nnull\n18.0\n\"Worsted\"\n\"malabrigo-yarn…\n4.73\n20638\n97630\n\"singles\"\nnull\n8\n210\n\"Malabrigo Yarn…\nnull\n1\n18.0\n\"Aran\"\n10\n8\n\"singles\"\n\n\nfalse\n4\n100\n62569\ntrue\n22.0\n18.0\n\"Rios\"\n\"malabrigo-yarn…\n4.81\n20250\n97421\n\"plied\"\nnull\nnull\n210\n\"Malabrigo Yarn…\nnull\n12\n20.0\n\"Worsted\"\n10\n9\n\"plied\"\n\n\nfalse\n4\n70\n818\ntrue\nnull\n20.0\n\"Sugar'n Cream …\n\"lily-sugarn-cr…\n4.11\n13053\n53632\n\"4 single plies…\nnull\nnull\n120\n\"Lily\"\nnull\n12\n20.0\n\"Worsted\"\n10\n9\n\"4 single plies…\n\n\nfalse\n4\n100\n3518\ntrue\n22.0\n20.0\n\"220 Superwash\"\n\"cascade-yarns-…\n4.42\n14828\n65478\nnull\nnull\nnull\n220\n\"Cascade Yarns …\nnull\n12\n20.0\n\"Worsted\"\n10\n9\nnull\n\n\nfalse\n4\n100\n26385\ntrue\nnull\n32.0\n\"Sock\"\n\"malabrigo-yarn…\n4.74\n18508\n87693\n\"plied\"\nnull\nnull\n440\n\"Malabrigo Yarn…\nnull\n13\n32.0\n\"Light Fingerin…\n3\nnull\n\"plied\"\n\n\nfalse\n4\nnull\n53539\ntrue\n30.0\n26.0\n\"Tosh Merino Li…\n\"madelinetosh-t…\n4.7\n15991\n75155\n\"single\"\nnull\nnull\n420\n\"madelinetosh\"\nnull\n5\n28.0\n\"Fingering\"\n4\n14\n\"single\"\nThe pl.DataFrame.describe() method gives a quick overview of the data.\nyarn.describe()\n\n\nshape: (9, 25)\n\n\n\ndescribe\ndiscontinued\ngauge_divisor\ngrams\nid\nmachine_washable\nmax_gauge\nmin_gauge\nname\npermalink\nrating_average\nrating_count\nrating_total\ntexture\nthread_size\nwpi\nyardage\nyarn_company_name\nyarn_weight_crochet_gauge\nyarn_weight_id\nyarn_weight_knit_gauge\nyarn_weight_name\nyarn_weight_ply\nyarn_weight_wpi\ntexture_clean\n\n\nstr\nf64\nf64\nf64\nf64\nf64\nf64\nf64\nstr\nstr\nf64\nf64\nf64\nstr\nstr\nf64\nf64\nstr\nf64\nf64\nf64\nstr\nf64\nf64\nstr\n\n\n\n\n\"count\"\n100000.0\n100000.0\n100000.0\n100000.0\n100000.0\n100000.0\n100000.0\n\"100000\"\n\"100000\"\n100000.0\n100000.0\n100000.0\n\"100000\"\n\"100000\"\n100000.0\n100000.0\n\"100000\"\n100000.0\n100000.0\n100000.0\n\"100000\"\n100000.0\n100000.0\n\"100000\"\n\n\n\"null_count\"\n90.0\n29596.0\n3782.0\n0.0\n45792.0\n79630.0\n29052.0\n\"0\"\n\"0\"\n10541.0\n10541.0\n10541.0\n\"26691\"\n\"99407\"\n96199.0\n4266.0\n\"0\"\n100000.0\n2695.0\n33384.0\n\"2695\"\n9380.0\n24074.0\n\"26691\"\n\n\n\"mean\"\n0.356531\n3.647705\n92.973841\n102988.0402\n0.673369\n19.162726\n20.069264\nnull\nnull\n4.426368\n43.181905\n189.281146\nnull\nnull\n12.93949\n339.035881\nnull\nnull\n7.454756\n24.481746\nnull\n6.393136\n11.144773\nnull\n\n\n\"std\"\n0.478977\n0.962701\n73.082122\n61006.727934\n0.468985\n10.170148\n8.030449\nnull\nnull\n0.631511\n320.643238\n1407.033498\nnull\nnull\n7.919564\n538.963237\nnull\nnull\n3.677407\n4.516639\nnull\n3.179723\n2.510025\nnull\n\n\n\"min\"\n0.0\n1.0\n0.0\n24.0\n0.0\n0.0\n0.0\n\"\"Der Halsschme…\n\"-\"\n1.0\n1.0\n1.0\n\"\"beads on a ch…\n\"1\"\n0.0\n0.0\n\"! Needs Brand …\nnull\n1.0\n18.0\n\"Aran\"\n1.0\n7.0\n\"\"beads on a ch…\n\n\n\"25%\"\nnull\n4.0\n50.0\n51014.0\nnull\n8.0\n15.0\nnull\nnull\n4.0\n2.0\n10.0\nnull\nnull\n9.0\n137.0\nnull\nnull\n5.0\n20.0\nnull\n4.0\n9.0\nnull\n\n\n\"50%\"\nnull\n4.0\n100.0\n103017.0\nnull\n20.0\n22.0\nnull\nnull\n4.6\n5.0\n23.0\nnull\nnull\n12.0\n246.0\nnull\nnull\n7.0\n22.0\nnull\n5.0\n11.0\nnull\n\n\n\"75%\"\nnull\n4.0\n100.0\n155436.0\nnull\n28.0\n28.0\nnull\nnull\n5.0\n17.0\n73.0\nnull\nnull\n14.0\n437.0\nnull\nnull\n11.0\n28.0\nnull\n10.0\n14.0\nnull\n\n\n\"max\"\n1.0\n4.0\n7087.0\n218285.0\n1.0\n67.75\n99.99\n\"빈센트 리치 시그니처 (V…\n\"zwool-worsted-…\n5.0\n21517.0\n97630.0\n\"одиночний розр…\n\"floss\"\n127.0\n32839.0\n\"니트러브(Knitlove)…\nnull\n16.0\n32.0\n\"Worsted\"\n12.0\n14.0\n\"одиночний розр…"
  },
  {
    "objectID": "posts/yarn/index.html#check-for-missing-values",
    "href": "posts/yarn/index.html#check-for-missing-values",
    "title": "Tidy Tuesday: analyzing yarns with polars",
    "section": "Check for missing values",
    "text": "Check for missing values\nA good first step in any exploratory data analysis is to check for missing values. Here, I’d like to know the percentage of missing values per column. The pl.DataFrame.describe() method already gives the number of missing values. I use .transpose() to turn the columns into rows, so I can use the pl.DataFrame.with_column() method to add a new column with the percentage of missing values.\n\n(\n    yarn.describe()\n    .filter(pl.col(\"describe\") == \"null_count\")\n    .drop(\"describe\")\n    .transpose(\n        include_header=True,\n        column_names=[\"null_count\"],\n    )\n    .with_columns(pl.col(\"null_count\").cast(pl.Float64))  # str -&gt; float\n    .with_columns((pl.col(\"null_count\") / yarn.shape[0]).alias(\"null_pct\"))\n    .sort(pl.col(\"null_pct\"), descending=True)\n)\n\n\nshape: (24, 3)\n\n\n\ncolumn\nnull_count\nnull_pct\n\n\nstr\nf64\nf64\n\n\n\n\n\"yarn_weight_cr…\n100000.0\n1.0\n\n\n\"thread_size\"\n99407.0\n0.99407\n\n\n\"wpi\"\n96199.0\n0.96199\n\n\n\"max_gauge\"\n79630.0\n0.7963\n\n\n\"machine_washab…\n45792.0\n0.45792\n\n\n\"yarn_weight_kn…\n33384.0\n0.33384\n\n\n\"gauge_divisor\"\n29596.0\n0.29596\n\n\n\"min_gauge\"\n29052.0\n0.29052\n\n\n\"texture\"\n26691.0\n0.26691\n\n\n\"texture_clean\"\n26691.0\n0.26691\n\n\n\"yarn_weight_wp…\n24074.0\n0.24074\n\n\n\"rating_average…\n10541.0\n0.10541\n\n\n\"rating_count\"\n10541.0\n0.10541\n\n\n\"rating_total\"\n10541.0\n0.10541\n\n\n\"yarn_weight_pl…\n9380.0\n0.0938\n\n\n\"yardage\"\n4266.0\n0.04266\n\n\n\"grams\"\n3782.0\n0.03782\n\n\n\"yarn_weight_id…\n2695.0\n0.02695\n\n\n\"yarn_weight_na…\n2695.0\n0.02695\n\n\n\"discontinued\"\n90.0\n0.0009\n\n\n\"id\"\n0.0\n0.0\n\n\n\"name\"\n0.0\n0.0\n\n\n\"permalink\"\n0.0\n0.0\n\n\n\"yarn_company_n…\n0.0\n0.0\n\n\n\n\n\n\nSome columns have close to 100% missing values, these won’t be useful for further analysis."
  },
  {
    "objectID": "posts/yarn/index.html#discontinued-yarns",
    "href": "posts/yarn/index.html#discontinued-yarns",
    "title": "Tidy Tuesday: analyzing yarns with polars",
    "section": "Discontinued yarns",
    "text": "Discontinued yarns\nThe column boolean column “discontinued” indicates whether a manufacturer has stopped producing a yarn. This sparked a question: are unpopular yarns more likely to be discontinued?\nLet’s see a boxplot of the rating average for discontinued and non-discontinued yarns. I visualize the data with plotly express. It can’t handle polars DataFrames, so I convert it to a pandas DataFrame first, using the pl.DataFrame.to_pandas() method.\n\ndiscontinued_df = yarn.select(\n    [\n        \"discontinued\",\n        \"rating_average\",\n    ]\n).drop_nulls()\n\nimport plotly.express as px\n\nfig = px.box(\n    data_frame=discontinued_df.to_pandas(),\n    x=\"discontinued\",\n    y=\"rating_average\",\n    title=\"Rating Average by Discontinued\",\n    color=\"discontinued\",\n)\nfig.show()\n\n\n                                                \n\n\nThe boxplot shows that discontinued yarns (True, in red) indeed have a lower rating than non-discontinued yarns. But is this difference statistically significant? I can use a t-test to find out. scipy.stats has a function for this. I’m choosing a two sample t-test, because I’m comparing two groups and I’m using a two-sided test because I don’t want to rule out that the discontinued yarns have a higher rating than the non-discontinued yarns.\nHere, I use the pl.Series.to_numpy() method to convert the polars Series to a numpy array.\n\nfrom scipy.stats import ttest_ind\n\nttest_ind(\n    a=discontinued_df.filter(pl.col(\"discontinued\") == True)\n    .select(\"rating_average\")\n    .to_numpy(),\n    b=discontinued_df.filter(pl.col(\"discontinued\") == False)\n    .select(\"rating_average\")\n    .to_numpy(),\n)\n\nTtestResult(statistic=array([-79.57208971]), pvalue=array([0.]), df=array([89384.]))\n\n\nSo yes, the result is statistically significant. The p-value is very small, so we can reject the null hypothesis that the two groups have the same rating average."
  },
  {
    "objectID": "posts/yarn/index.html#most-popular-yarn-companies",
    "href": "posts/yarn/index.html#most-popular-yarn-companies",
    "title": "Tidy Tuesday: analyzing yarns with polars",
    "section": "Most popular yarn companies",
    "text": "Most popular yarn companies\nLet’s have a closer look at the yarn companies. I aggregate the data frame by yarn company and calculate a number of statistics about them.\n\ncompanies = (\n    yarn.groupby(\"yarn_company_name\")\n    .agg(\n        [\n            pl.count().alias(\"yarns\"),\n            pl.mean(\"rating_average\").alias(\"mean_rating_average\"),\n            pl.sum(\"rating_count\").alias(\"total_ratings\"),\n        ]\n    )\n    .filter(pl.col(\"total_ratings\") &gt; 499)\n    .sort(pl.col(\"total_ratings\"), descending=True)\n)\ncompanies\n\n/var/folders/y6/r4nd18014svggynr61y82m4w0000gn/T/ipykernel_21945/1280698066.py:2: DeprecationWarning:\n\n`groupby` is deprecated. It has been renamed to `group_by`.\n\n\n\n\nshape: (644, 4)\n\n\n\nyarn_company_name\nyarns\nmean_rating_average\ntotal_ratings\n\n\nstr\nu32\nf64\ni32\n\n\n\n\n\"Knit Picks\"\n264\n4.345615\n168175\n\n\n\"Cascade Yarns …\n256\n4.271111\n153626\n\n\n\"Lion Brand\"\n390\n3.979581\n149327\n\n\n\"Malabrigo Yarn…\n42\n4.676585\n111182\n\n\n\"Rowan\"\n267\n4.288669\n99200\n\n\n\"Garnstudio\"\n92\n4.083111\n86275\n\n\n\"Berroco\"\n323\n4.109444\n85314\n\n\n\"madelinetosh\"\n92\n4.733\n76651\n\n\n\"Red Heart\"\n346\n3.891916\n72135\n\n\n\"Bernat\"\n461\n3.842055\n63405\n\n\n\"Plymouth Yarn\"\n391\n4.153069\n61151\n\n\n\"Patons North A…\n224\n3.835442\n60843\n\n\n…\n…\n…\n…\n\n\n\"Huckleberry Kn…\n53\n4.739583\n514\n\n\n\"The Copper Cor…\n13\n4.878462\n514\n\n\n\"Graine de lain…\n16\n4.731875\n514\n\n\n\"Sunrise Fiber …\n35\n4.858824\n513\n\n\n\"Another Crafty…\n11\n4.923636\n512\n\n\n\"Midara\"\n41\n4.478286\n512\n\n\n\"Kangaroo Dyer\"\n17\n4.445882\n510\n\n\n\"Needful Yarns\"\n40\n3.782051\n509\n\n\n\"Carnival\"\n12\n3.671\n508\n\n\n\"Sterling Ridge…\n19\n4.820556\n508\n\n\n\"WOLLkenSchaf\"\n21\n4.67\n507\n\n\n\"Farbularasa\"\n29\n4.911111\n504\n\n\n\n\n\n\nThe table shows brands with at least 500 ratings on Ravelry. Lion Brand stands out with a particularly low average rating of 3.98, whereas madelinetosh scores an average rating of 4.73."
  },
  {
    "objectID": "posts/yarn/index.html#yarn-weights",
    "href": "posts/yarn/index.html#yarn-weights",
    "title": "Tidy Tuesday: analyzing yarns with polars",
    "section": "Yarn weights",
    "text": "Yarn weights\nMy girlfriend, who is a passionate knitter, tells me that gauge weight is the most important factor for a knitting project. It determines the thickness and size of the finished product. It’s associated with the yarn_weight_ply, which is the number of threads combined to a yarn.\nWhich gauge sizes are most popular, based on the number of yarns available?\n\n(\n    yarn.groupby([\"yarn_weight_name\", \"yarn_weight_ply\"])\n    .agg(\n        [\n            pl.count().alias(\"yarns\"),\n        ]\n    )\n    .drop_nulls()\n    .sort(pl.col(\"yarns\"), descending=True)\n)\n\n/var/folders/y6/r4nd18014svggynr61y82m4w0000gn/T/ipykernel_21945/155294860.py:2: DeprecationWarning:\n\n`groupby` is deprecated. It has been renamed to `group_by`.\n\n\n\n\nshape: (9, 3)\n\n\n\nyarn_weight_name\nyarn_weight_ply\nyarns\n\n\nstr\ni32\nu32\n\n\n\n\n\"Fingering\"\n4\n26004\n\n\n\"DK\"\n8\n15686\n\n\n\"Aran\"\n10\n9292\n\n\n\"Worsted\"\n10\n9156\n\n\n\"Sport\"\n5\n8464\n\n\n\"Lace\"\n2\n7504\n\n\n\"Bulky\"\n12\n7324\n\n\n\"Light Fingerin…\n3\n6478\n\n\n\"Cobweb\"\n1\n712\n\n\n\n\n\n\nThe “Fingering” weight, a regular yarn for knitting, is the most popular gauge weight. According to my girlfriend, it’s particularly popular in Scandinavia.\nThe yardage, weight and thickness of yarn is expressed with multiple metrics. Let’s see the correlation between them to better understand their meanings. Polars doesn’t have a built-in function to get the correlation between all columns. The pl.pearson_corr() function can be used to calculate the correlation between two columns. I convert it to a pandas DataFrame to use its corr() method.\n\ncorr = (\n    yarn.select(\n        [\n            \"yardage\",\n            \"grams\",\n            \"machine_washable\",\n            \"max_gauge\",\n            \"min_gauge\",\n            \"yarn_weight_ply\",\n            \"yarn_weight_knit_gauge\",\n            \"yarn_weight_wpi\",\n        ]\n    )\n    .drop_nulls()\n    .to_pandas()\n    .corr()\n)\n\n# Visualize as a heatmap using plotly\n\nimport plotly.io as pio\nimport plotly.graph_objects as go\n\npio.templates.default = \"plotly_white\"\n\n# Only show the upper triangle of the correlation matrix\n# Set the diagonal and lower triangle to NaN\nimport numpy as np\n\nmask = np.triu(np.ones_like(corr, dtype=bool))\n\nfig = go.Figure()\nfig.add_trace(\n    go.Heatmap(\n        z=corr.mask(mask),\n        x=corr.columns,\n        y=corr.columns,\n        colorscale=px.colors.diverging.RdBu,\n        zmin=-1,\n        zmax=1,\n    )\n)\n\n\n                                                \n\n\nThe correlation matrix shows some facts about yarns:\n\nLong yarns (high yardage) makes the yarn ball heavier (high grams)\nHigh ply yarns are typically sold in shorter yardage\nHigh ply yarns are less commonly mashine washable\nThe maximum and minimum gauge are in a small range of one another, depending on the yarn weight\nA thick yarn (high ply, high WPI (wraps per inch)) means fewer stitches fit into the gauge\n\nAnd that’s it! I hope you’ve enjoyed this analysis of the Ravelry yarn data. If you want to learn more about polars, check out the documentation and the GitHub repository.\nPhoto by Margarida Afonso on Unsplash"
  },
  {
    "objectID": "posts/fangmant/index.html",
    "href": "posts/fangmant/index.html",
    "title": "FANGMANT: Tech stock analysis with pandas",
    "section": "",
    "text": "The acronym FANGMANT stands for Facebook, Apple, Netflix, Google, Microsoft, Amazon, Nvidia and Tesla. Large, highly profitable US tech companies that dominate their respective markets. Other common acronyms are FANG, FAANG and FANGMAN.\nIn this article, I’m analyzing their stock performance from 2016 to 2021.\nDisclaimer: This article is not financial advice. It’s a data analysis for fun."
  },
  {
    "objectID": "posts/fangmant/index.html#download-with-yfinance",
    "href": "posts/fangmant/index.html#download-with-yfinance",
    "title": "FANGMANT: Tech stock analysis with pandas",
    "section": "Download with yfinance",
    "text": "Download with yfinance\nyfinance is a Python package that downloads financial data from Yahoo! Finance. It does not require an API key or other authentication. It’s meant for personal use and research.\n\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nfrom pathlib import Path\n\n\ntickers = [\n  \"FB\",   # Meta / Facebook\n  \"AAPL\", # Apple\n  \"NFLX\", # Netflix\n  \"GOOG\", # Alphabet / Google\n  \"MSFT\", # Microsoft\n  \"AMZN\", # Amazon\n  \"NVDA\", # Nvidia\n  \"TSLA\",  # Tesla,\n  \"URTH\" # MSCI World\n]\n\nDownload historical prices from Yahoo! Finance by Ticker Symbol.\nIn addition to the FANGMANT Tickers, I added URTH for the MSCI World, a broad index ETF that includes more than 1600 individual stocks from 23 developed countries. It also includes the FANGMANT stocks, along with the stocks of the companies with the highest market capitalization across all industries.\nThe data is saved as a pickled pandas data frame, so it doesn’t have to be downloaded again. The pickle format maintains the index and multi-level structure of the data frame, which would be lost in the CSV format.\n\n# Save as a file to avoid having to download again\ndata_path = Path(\"data.pkl\")\n\nif data_path.is_file():\n  data_imported = pd.read_pickle(data_path)\nelse: \n  data_imported = yf.download(\n    tickers = \" \".join(tickers),\n    period = \"5y\",\n    interval = \"1d\",\n    group_by = \"ticker\",\n    auto_adjust = True,\n    prepost = False,\n    threads = True,\n    proxy = None\n  )\n  \n  data_imported.to_pickle(data_path)\n\n\n[                       0%%                      ]\n[***********           22%%                      ]  2 of 9 completed\n[****************      33%%                      ]  3 of 9 completed\n[********************* 44%%                      ]  4 of 9 completed\n[**********************56%%*                     ]  5 of 9 completed\n[**********************67%%******                ]  6 of 9 completed\n[**********************78%%***********           ]  7 of 9 completed\n[**********************89%%*****************     ]  8 of 9 completed\n[*********************100%%**********************]  9 of 9 completed\n\n\n1 Failed download:\n['FB']: Exception('%ticker%: No data found, symbol may be delisted')\n\n  \ndata_imported\n\n                  MSFT              ...        AAPL           \n                  Open        High  ...       Close     Volume\nDate                                ...                       \n2018-10-18  104.312215  104.719611  ...   51.722408  130325200\n2018-10-19  103.203733  105.032276  ...   52.510147  132314800\n2018-10-22  103.573227  104.729094  ...   52.830986  115168400\n2018-10-23  102.104697  103.241619  ...   53.329002  155071200\n2018-10-24  102.711062  102.786851  ...   51.499729  163702000\n...                ...         ...  ...         ...        ...\n2023-10-11  331.209991  332.820007  ...  179.800003   47551100\n2023-10-12  330.570007  333.630005  ...  180.710007   56743100\n2023-10-13  332.380005  333.829987  ...  178.850006   51427100\n2023-10-16  331.049988  336.140015  ...  178.720001   52517000\n2023-10-17  329.589996  333.459991  ...  177.149994   57515400\n\n[1257 rows x 46 columns]\n\n\nThe pandas data frame has multi-level columns. Each ticker symbol (FB, AAPL, …) is a column which has the Open, High, Low and Close as sub-columns. This data structure is hard to work with. StackOverflow conveniently has an answer to the exact issue. I went with the option of turning the wide data frame into a long data frame with a Ticker column.\n\ndata = data_imported.stack(level=0).rename_axis([\"Date\", \"Ticker\"]).reset_index(level=1)\ndata\n\n           Ticker  Adj Close       Close  ...         Low        Open       Volume\nDate                                      ...                                     \n2018-10-18   AAPL        NaN   51.722408  ...   50.999318   52.162965  130325200.0\n2018-10-18   AMZN        NaN   88.536003  ...   88.393501   91.074501  117480000.0\n2018-10-18   GOOG        NaN   54.398499  ...   53.854500   56.091999   41890000.0\n2018-10-18   MSFT        NaN  102.796326  ...  102.161548  104.312215   32506200.0\n2018-10-18   NFLX        NaN  346.709991  ...  346.049988  360.670013   18461000.0\n...           ...        ...         ...  ...         ...         ...          ...\n2023-10-17   MSFT        NaN  332.059998  ...  327.410004  329.589996   18300900.0\n2023-10-17   NFLX        NaN  355.720001  ...  353.890015  361.100006    5894300.0\n2023-10-17   NVDA        NaN  439.380005  ...  424.799988  440.000000   80998800.0\n2023-10-17   TSLA        NaN  254.850006  ...  247.080002  250.100006   93451900.0\n2023-10-17   URTH        NaN  121.839996  ...  120.889999  120.949997     220100.0\n\n[10056 rows x 7 columns]\n\n\nThe stack method puts first level (0) column names into the index. This pivots the data frame, going from a wide format (one row per day) to a long format (one row per day per ticker). rename_axis gives names to the index columns. reset_index changes the custom index with two columns (Date and Ticker) to the default index, which is a DatetimeIndex on the Date column.\n\ndata.index\n\nDatetimeIndex(['2018-10-18', '2018-10-18', '2018-10-18', '2018-10-18',\n               '2018-10-18', '2018-10-18', '2018-10-18', '2018-10-18',\n               '2018-10-19', '2018-10-19',\n               ...\n               '2023-10-16', '2023-10-16', '2023-10-17', '2023-10-17',\n               '2023-10-17', '2023-10-17', '2023-10-17', '2023-10-17',\n               '2023-10-17', '2023-10-17'],\n              dtype='datetime64[ns]', name='Date', length=10056, freq=None)\n\nstart_time = data.index[0]\nend_time = data.index[-1]\n\nThe first data point is at 2018-10-18 02:00:00 and the last one is at 2023-10-17 02:00:00."
  },
  {
    "objectID": "posts/fangmant/index.html#returns",
    "href": "posts/fangmant/index.html#returns",
    "title": "FANGMANT: Tech stock analysis with pandas",
    "section": "Returns",
    "text": "Returns\nLet’s calculate the returns of each stock for each year. I’ll use the Close prices for each day. I’ll also add the volatility as a measure of investment risk.\n\ndef growth(series: pd.Series) -&gt; float:\n  return series[-1]  / series[0] - 1\n\ndef volatility(series: pd.Series, n_days: int = 252) -&gt; pd.Series:\n  returns = np.log(series / series.shift(-1))\n  daily_std = np.std(returns)\n  std = daily_std * n_days ** 0.5\n  return(std)\n\n\naggregated = (data\n  .assign(Year = data.index.year)\n  .query(\"Year &gt;= 2017\")\n  .groupby([\"Ticker\", \"Year\"])\n  .agg(\n    growth = (\"Close\", growth),\n    volatility = (\"Close\", volatility),\n    trading_days = (\"Close\", \"count\"),\n    first = (\"Close\", \"first\"),\n    last = (\"Close\", \"last\"),\n    high = (\"Close\", \"max\"),\n    low = (\"Close\", \"min\")\n  )\n).reset_index()\n\nI use the reactable R package to build an interactive results table as an htmlwidget. Thanks to reticulate, the handover from Python to R is seamless. The Python dataframe is available as py$aggregated. One small drawback: the R representation doesn’t include the multi index created by the group by operation in Python, which is why I used reset_index.\n\n# Define function for conditional styling of cells\ncolors &lt;- function(value) {\n  if (value &gt; 0) {\n    color &lt;- \"green\"\n  } else if (value &lt; 0) {\n    color &lt;- \"red\"\n  } else {\n    color &lt;- \"#777\"\n  }\n  list(color = color, fontWeight = \"bold\")\n}\n\nreactable(\n  data = py$aggregated,\n  compact = TRUE,\n  highlight = TRUE,\n  showSortable = TRUE,\n  defaultSorted = \"Ticker\",\n  columns = list(\n    growth = colDef(\n      name = \"Growth\", \n      style = colors, \n      format = colFormat(percent = TRUE, digits = 2)\n    ),\n    volatility = colDef(name = \"Volatility\", format = colFormat(digits = 2)),\n    trading_days = colDef(name = \"Trading Days\"),\n    last = colDef(name = \"Last\", format = colFormat(digits = 2)),\n    first = colDef(name = \"First\", format = colFormat(digits = 2)),\n    high = colDef(name = \"High\", format = colFormat(digits = 2)),\n    low = colDef(name = \"Low\", format = colFormat(digits = 2))\n  ),\n  columnGroups = list(\n    colGroup(\n      name = \"Stock Price in USD\", \n      columns = c(\"first\", \"last\", \"high\" ,\"low\")\n    )\n  )\n)\n\n\n\n\n\n\nSorting by year reveals that 2018 was a rather bad year for FANGMANT. Apple, Facebook, Nvidia and Google lost in value. But it wasn’t universal: Amazon, Microsoft, Tesla and Netflix rose. The MSCI World took a 9.25% dive."
  },
  {
    "objectID": "posts/fangmant/index.html#stock-performance-over-time",
    "href": "posts/fangmant/index.html#stock-performance-over-time",
    "title": "FANGMANT: Tech stock analysis with pandas",
    "section": "Stock performance over time",
    "text": "Stock performance over time\nTo visualize the stock developments over time, they have to be scaled to the same initial level. Otherwise, all we’d see is the difference in the price of each individual stock.\nFirst, I export the data to R.\n\ndata_chart = (data\n  .filter(items = [\"Ticker\", \"Date\", \"Close\"])\n  .reset_index()\n)\n\nThe grouped mutate operation is much easier to do in dplyr than in pandas.\nFor visualization, I use echarts4r, which I wrote about in a previous article.\n\npy$data_chart |&gt;\n  group_by(Ticker) |&gt;\n  dplyr::mutate(Close = Close / Close[1]) |&gt;\n  e_charts(x = Date) |&gt;\n  e_line(serie = Close, symbol = \"none\") |&gt;\n  e_tooltip(trigger = \"axis\") |&gt;\n  e_axis_labels(y = \"Value (indexed)\")\n\n\n\n\n\nClick on the Ticker names to hide individual series. This rescales the axes and allows more detailed views of all time series.\nTesla had the strongest performance, thanks to the amazing 720% growth in 2020. The second winner is Nvidia, which recently experience a strong rise. The MSCI World grew at a comparatively stop but steady pace, yet still reached 204% of its initial valuation."
  },
  {
    "objectID": "posts/fangmant/index.html#growth-vs-volatility",
    "href": "posts/fangmant/index.html#growth-vs-volatility",
    "title": "FANGMANT: Tech stock analysis with pandas",
    "section": "Growth vs volatility",
    "text": "Growth vs volatility\nStronger growth opportunities typically come at the cost of increased risk. To check how true this is among FANGMANT and the MSCI World as a reference, I plot the yearly returns and volatilities in a scatterplot.\n\npy$aggregated |&gt;\n  dplyr::mutate(type = ifelse(Ticker == \"URTH\", \"MSCI World ETF\", \"Individual FANGMANT stock\")) |&gt;\n  group_by(type) |&gt;\n  e_charts(x = growth) |&gt;\n  e_scatter(\n    serie = volatility,\n    symbol_size = 10\n  ) |&gt;\n  e_axis_labels(x = \"Return\", y = \"Volatility\")\n\n\n\n\n\nIn line with theory, the individual stocks have higher volatility than the ETF. There’s a tradeoff between returns and stability.\nAccording to the classic Markowitz model, I’d expect that an analysis that includes more stocks (not just the most famous tech stocks) would show that the average return of stocks is the same as that of the MSCI World, but at a higher volatility. Therefore, it would be better to hold the MSCI World than picking random individual stocks as it is at the efficient frontier."
  },
  {
    "objectID": "posts/fangmant/index.html#conclusion",
    "href": "posts/fangmant/index.html#conclusion",
    "title": "FANGMANT: Tech stock analysis with pandas",
    "section": "Conclusion",
    "text": "Conclusion\nFANGMANT performed amazingly well in the last 5 years and outperformed the MSCI world. While the MSCI World doubled in 5 years, Facebook, the worst of the FANGMANT performers, tripled in value.\nContrary to other industries, FANGMANT and the tech stocks as a whole were not affected by the pandemic. This also stabilized the MSCI World, which had a dip but recovered within months.\nWill FANGMANT continue to outperform the MSCI World? Hundreds of thousands of analysts are trying to figure it out. According to the efficient market hypothesis, all information is already priced in, including expected future developments (new inventions, products, management practices, consumption cycles). An investor without inside information can’t predict the future price. But the theory isn’t without criticism.\nPhoto by Maxim Hopman on Unsplash"
  },
  {
    "objectID": "posts/devskill/index.html",
    "href": "posts/devskill/index.html",
    "title": "Investing in data science skills for the long run",
    "section": "",
    "text": "Data science is a field that is constantly evolving and requires a lot of practice to master. Picking the right skills to focus on is critical for career development.\nThe first distinction I see is between gig skills that are useful for a single project or job and long-term skills that benefit you for your whole career. Telling the two types apart will let you invest your time more effectively.\nLong-term skills are generally a better investment than gig skills. Focusing too much on gig skills can turn you into a perpetual beginner. In every new job or project, you need to start from scratch learning skills that lose their value quickly. But investing in selected ephermeral skill can still be smart. It is often necessary to learn the particularities of a software system you’re working with to be effective."
  },
  {
    "objectID": "posts/devskill/index.html#specialists-turn-gig-skills-turn-into-long-term-skills",
    "href": "posts/devskill/index.html#specialists-turn-gig-skills-turn-into-long-term-skills",
    "title": "Investing in data science skills for the long run",
    "section": "Specialists turn gig skills turn into long-term skills",
    "text": "Specialists turn gig skills turn into long-term skills\nA skill that is gig skill for a generalist may be a long-term skill for a specialist. Imagine a data scientist that wants to provision resources on an AWS account. Their company uses AWS CDK for infrastructure as code. Learning the AWS CDK is a gig skill for the data scientist, because the next job may be at a company that uses Azure or Google Cloud. But for a dedicated AWS cloud data engineer, learning the AWS CDK is a long-term skill that pays off over and over."
  },
  {
    "objectID": "posts/devskill/index.html#golden-long-term-skills",
    "href": "posts/devskill/index.html#golden-long-term-skills",
    "title": "Investing in data science skills for the long run",
    "section": "Golden long-term skills",
    "text": "Golden long-term skills\nA few skills stand out as eternally valuable for anyone in data science. They’re likely to pay off for a whole career.\n\nDescriptive statistics and probability distributions: Understanding variance, quantiles, conditional probability and hypothesis tests is essential. These building blocks of statistics won’t change.\nLinear regression and its variants: These can answer many questions by themselves and also serve as a benchmark for more sophisticated machine learning algorithms. Understanding variants like logistic regression and regularized least squares widens the range of questions you can answer and deepens your understanding of machine learning.\nData visualization principles: A visual expression of data makes the information more accessible. Knowing which visualization is suitable for different types of data and questions makes you a more competent communicator and multiplies the impact your analyses have. Note that I’m only referring to the principles as long-term skills. The plotting libraries come and go.\nEffective writing: Whether it’s writing a report, a proposal, a support ticket or an email: Writing with clarity boosts anyone’s effectiveness.\nSQL: This is the only language on the list. SQL is ubiquitous and has been in use for almost 50 years. Being able to access data at the source is essential for anyone working in the data industry. The SQL standard changes very slowly. Different databases implement variants of the language, but the core commands work everywhere.\nGit: Using version control is non-negotiable when working in a team and Git is the unanimous leading choice.\nText editor mastery: Using a text editor or IDE efficiently by touch typing and keyboard shortcuts removes a barrier. Speed isn’t the point, it’s freeing your mind from needing to expend energy on typing. To safeguard your skill investment, use a free editor that supports many programming languages, for example Visual Studio Code.\n\nIf you don’t know what to start with, practice a golden long-term skill."
  },
  {
    "objectID": "posts/devskill/index.html#pick-one-skills",
    "href": "posts/devskill/index.html#pick-one-skills",
    "title": "Investing in data science skills for the long run",
    "section": "Pick-one skills",
    "text": "Pick-one skills\nThis is a class of skills that are required in a wide range of data science projects, but that have many implementations of which only one is used at a time.\n\nA programming language: While it’s possible to analyze data entirely within a GUI, it severely limits what you can build. R and Python are the two top choices for programming data analysis. You can also program it with Julia, Java and many other languages, but R and Python have the most package libraries and widest support.\nA charting library: Creating visualizations with code makes them reuseable, reproducible and with some practice also quicker to make. There are endless charting libraries. Some popular examples are: ggplot2, matplotlib, seaborn, echarts.\nA machine learning framework: Examples are: scikit-learn, tidymodels, caret, mlr3. When using neural networks, one of Pytorch or Tensorflow is typically required.\nA data quality testing library: Examples are: pointblank, Great Expectations. You could also use constraints in a SQL database.\nA package manager: Examples are: renv, pip, poetry, conda.\nAn orchestration platform: Examples are Airflow, Dagster, drake, dbt. Data scientists often don’t have to set these up and maintain them themselves, but need to know how to submit and monitor jobs running on them.\n\nThese can end up as gig skills. Throughout your career, you’ll likely have to switch between them, either because a new library outshines the older ones or because you join a team that uses a different one. Each switch incurs a cost of relearning. Thankfully, the different implementations often share principles. Learning your third visualization library will be much faster than the first. Smart hiring managers understand that these can be picked up on the job."
  },
  {
    "objectID": "posts/devskill/index.html#vendor-and-project-specific-skills",
    "href": "posts/devskill/index.html#vendor-and-project-specific-skills",
    "title": "Investing in data science skills for the long run",
    "section": "Vendor and project specific skills",
    "text": "Vendor and project specific skills\n\nFine details of cloud platforms\nProprietary software that isn’t widely used\nInternal tools not available to the public\n\nThese are most likely to become gig skills, unless you make it a career choice and specialize in them."
  },
  {
    "objectID": "posts/devskill/index.html#domain-knowledge",
    "href": "posts/devskill/index.html#domain-knowledge",
    "title": "Investing in data science skills for the long run",
    "section": "Domain knowledge",
    "text": "Domain knowledge\nKnowing more about the subject matter behind the data you’re analyzing lets you ask better questions and avoid silly mistakes.\nIf you switch industries, previous domain knowledge loses its value. As an example, I’m currently not using any of the domain knowledge I acquired studying economics, while the statistical methods continue to be useful.\nSome fields of data science require deep industry specialization and corresponding certifications, for example in health, biology, accounting, insurance and other highly regulated industries. This is a form of specialization in domain knowledge.\nThanks for reading! Do you agree with my skill categorization? Let me know on Twitter.\nPhoto by Nina Luong on Unsplash"
  },
  {
    "objectID": "posts/echarts4r/index.html",
    "href": "posts/echarts4r/index.html",
    "title": "Exploring echarts4r",
    "section": "",
    "text": "As web-oriented presentation in R Markdown and Shiny becomes more and more popular, there is increasing demand for interactive graphics with R. Whereas ggplot2 and its vast extension ecosystem is clearly leading in static graphics, there is no one go-to package for interactivity. This article is a tour of echarts4r, an interface with the echarts.js JavaScript library.\nThere are numerous options for interactive graphics with R:\nIn addition, there are many packages specializing in a type of graph, such as dygraphs (time series) and visNetwork (network graphs).\necharts4r is a relatively new addition (CRAN release was 2018-09-17). It is an R interface with echarts.js, a free JavaScript charting library developed by Baidu and now part of the Apache Foundation."
  },
  {
    "objectID": "posts/echarts4r/index.html#why-echarts",
    "href": "posts/echarts4r/index.html#why-echarts",
    "title": "Exploring echarts4r",
    "section": "Why echarts?",
    "text": "Why echarts?\n\nCharts look great out of the box, especially the opening animations, tooltips and hover highlighting look great and work on mobile too\nWhile Plotly is optimized for exploratory data visualization by experts, echarts provides simpler interactions for a general audience, similar to Highcharts\nIt covers almost all chart types imaginable, so there’s no need to switch between packages and have inconsistent styling\necharts.js is highly customizable and it thoroughly documented (see documentation and cheat sheet cheat sheet). There is also a giant library of examples, all with source code\nIt’s free to use commercially, unlike Highcharts, which otherwise ticks the same boxes\nIn the development version, echarts4r offers proxies for interaction with Shiny (see https://echarts4r.john-coene.com/articles/shiny.html)\n\nIn addition to these advantages, it also offers features not seen in other packages (or at least not in this specific form): Geospatial 3D maps and timelines\nIn terms of ease of use, I’d put echarts4r in the middle of the pack. The R documentation is easy to follow and has good examples, but it cannot cover every detail, so one has to consult the official echarts documentation frequently. However, in contrast with learning D3 from scratch, this doesn’t take much time, an advantage that GitLab also noted in their comparison. As a long time ggplot2 user, I do miss the in-depth aesthetic mappings of ggplot2, faceting and ease of use when customizing axes. One last thing to keep in mind is that as a recent package and a larger userbase in China than in the West, StackOverflow doesn’t yet have many questions and answers on echarts."
  },
  {
    "objectID": "posts/echarts4r/index.html#lets-get-started",
    "href": "posts/echarts4r/index.html#lets-get-started",
    "title": "Exploring echarts4r",
    "section": "Let’s get started",
    "text": "Let’s get started\nThe remainder of this article is a tour of echarts4r’s features using the nycflights13 dataset. The official package website shows many more types of graphs, including maps, which are not covered here.\n\nlibrary(echarts4r)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(nycflights13)\nlibrary(stringr)"
  },
  {
    "objectID": "posts/echarts4r/index.html#set-a-theme",
    "href": "posts/echarts4r/index.html#set-a-theme",
    "title": "Exploring echarts4r",
    "section": "Set a theme",
    "text": "Set a theme\nLike ggplot’s theme_set(), e_common() let’s us set a theme for all plots to come.\n\ne_common(font_family = \"helvetica\", theme = \"westeros\")"
  },
  {
    "objectID": "posts/echarts4r/index.html#bar-charts",
    "href": "posts/echarts4r/index.html#bar-charts",
    "title": "Exploring echarts4r",
    "section": "Bar charts",
    "text": "Bar charts\nWe start with a classic bar chart. Composition is similar to ggplot’s geom_col() and even e_flip_coords() sounds suspiciously like ggplot’s coord_flip().\nA little quirk of the package is that its Chinese origins at Baidu sometimes show through. Here, I gave the save as image button a new English title instead of the Chinese tooltip.\n\nHorizontal bar chart\n\ntop_destinations &lt;- flights %&gt;%\n    count(dest) %&gt;%\n    top_n(15, n) %&gt;%\n    arrange(n)\n\ntop_destinations %&gt;%\n    e_charts(x = dest) %&gt;%\n    e_bar(n, legend = FALSE, name = \"Flights\") %&gt;%\n    e_labels(position = \"right\") %&gt;%\n    e_tooltip() %&gt;%\n    e_title(\"Flights by destination\", \"Top 15 destinations\") %&gt;%\n    e_flip_coords() %&gt;%\n    e_y_axis(splitLine = list(show = FALSE)) %&gt;%\n    e_x_axis(show = FALSE) %&gt;%\n    e_toolbox_feature(\n        feature = \"saveAsImage\",\n        title = \"Save as image\"\n    )\n\n\n\n\n\n\n\nStacked bar chart\necharts uses grouping with dplyr::group_by() instead of an aes() function like ggplot2 and highcharter.\n\nflights_daytime &lt;- flights %&gt;%\n    transmute(origin, daytime = case_when(\n        hour &gt;= 22 & hour &lt; 6 ~ \"Night\",\n        hour &gt;= 6 & hour &lt; 12 ~ \"Morning\",\n        hour &gt;= 12 & hour &lt; 18 ~ \"Afternoon\",\n        TRUE ~ \"Evening\"\n    )) %&gt;%\n    count(origin, daytime) %&gt;%\n    group_by(daytime)\nflights_daytime %&gt;%\n    e_charts(origin, stack = \"grp\") %&gt;%\n    e_bar(n) %&gt;%\n    e_tooltip(\n        trigger = \"axis\",\n        axisPointer = list(\n            type = \"shadow\"\n        )\n    ) %&gt;%\n    e_title(\n        text = \"Outgoing flights by time of day\",\n        subtext = \"There are no night flights\"\n    ) %&gt;%\n    e_y_axis(\n        splitArea = list(show = FALSE),\n        splitLine = list(show = FALSE)\n    )"
  },
  {
    "objectID": "posts/echarts4r/index.html#scatter-plot",
    "href": "posts/echarts4r/index.html#scatter-plot",
    "title": "Exploring echarts4r",
    "section": "Scatter plot",
    "text": "Scatter plot\nI plot arrival delay and departure delay. The original dataset has 336776 rows, which is too much to plot. I simply draw a sample of 1000 rows for the scatterplot and later show the full data in a heatmap.\nFor 1000 closely clustered points, it doesn’t make much sense to have a tooltip for each of them, so I used spike lines instead (called axis pointers in echarts).\nA linear regression model fits the relationship between arrival and departure delay well, so I added a regression line with the convenient e_lm() function.\n\nset.seed(123)\nflights_sm &lt;- flights %&gt;%\n    filter(complete.cases(.)) %&gt;%\n    sample_n(1000)\nflights_sm %&gt;%\n    e_charts(x = dep_delay) %&gt;%\n    e_scatter(arr_delay, name = \"Flight\") %&gt;%\n    e_lm(arr_delay ~ dep_delay, name = \"Linear model\") %&gt;%\n    e_axis_labels(x = \"Departure delay\", y = \"Arrival delay\") %&gt;%\n    e_title(\n        text = \"Arrival delay vs. departure delay\",\n        subtext = \"The later you start, the later you finish\"\n    ) %&gt;%\n    e_x_axis(\n        nameLocation = \"center\",\n        splitArea = list(show = FALSE),\n        axisLabel = list(margin = 3),\n        axisPointer = list(\n            show = TRUE,\n            lineStyle = list(\n                color = \"#999999\",\n                width = 0.75,\n                type = \"dotted\"\n            )\n        )\n    ) %&gt;%\n    e_y_axis(\n        nameLocation = \"center\",\n        splitArea = list(show = FALSE),\n        axisLabel = list(margin = 0),\n        axisPointer = list(\n            show = TRUE,\n            lineStyle = list(\n                color = \"#999999\",\n                width = 0.75,\n                type = \"dotted\"\n            )\n        )\n    )\n\n\n\n\n\n\nn_bins &lt;- 100 # binning\nflights %&gt;%\n    filter(complete.cases(.)) %&gt;%\n    mutate(\n        arr_delay = cut(arr_delay, n_bins),\n        dep_delay = cut(dep_delay, n_bins)\n    ) %&gt;%\n    count(arr_delay, dep_delay) %&gt;%\n    e_charts(dep_delay) %&gt;%\n    e_heatmap(arr_delay, n) %&gt;%\n    e_visual_map(n) %&gt;%\n    e_title(\"Arrival delay vs. departure delay\") %&gt;%\n    e_axis_labels(\"Departure delay\", \"Arrival delay\")"
  },
  {
    "objectID": "posts/echarts4r/index.html#pie-chart",
    "href": "posts/echarts4r/index.html#pie-chart",
    "title": "Exploring echarts4r",
    "section": "Pie chart",
    "text": "Pie chart\nPie charts tend to be a bad choice for accurate visualization, but they look nice. Here, the plot shows about even numbers of flights for the three origin airports, but it’s near impossible to tell that EWR has the most flights. Creating pie charts is surprisingly hard in ggplot2, especially when it comes to labeling them. In echarts it’s very easy.\n\npie &lt;- count(flights, origin) %&gt;%\n    e_charts(x = origin) %&gt;%\n    e_pie(n, legend = FALSE, name = \"Flights\") %&gt;%\n    e_tooltip() %&gt;%\n    e_title(\"Flights by origin\", \"This is really hard with ggplot2\")\npie"
  },
  {
    "objectID": "posts/echarts4r/index.html#time-series",
    "href": "posts/echarts4r/index.html#time-series",
    "title": "Exploring echarts4r",
    "section": "Time series",
    "text": "Time series\nI need time series graphs for an upcoming project, so that’ll be a focus of this article. Let’s analyze departure delays from all three origin airports.\n\nflights_ts &lt;- flights %&gt;%\n    transmute(week = as.Date(cut(time_hour, \"week\")), dep_delay, origin) %&gt;%\n    group_by(origin, week) %&gt;% # works with echarts\n    summarise(dep_delay = sum(dep_delay, na.rm = TRUE), .groups = \"drop_last\")\n\n\nRegular time series\nAfter much testing, I found that the way Highcharts does time series is the most intuitive and easy to use. The graph has a slider on the bottom for zooming, tooltips for multiple series are collected in one box and points grow when brushing over them.\n\nts_base &lt;- flights_ts %&gt;%\n    e_charts(x = week) %&gt;%\n    e_datazoom(\n        type = \"slider\",\n        toolbox = FALSE,\n        bottom = -5\n    ) %&gt;%\n    e_tooltip() %&gt;%\n    e_title(\"Departure delays by airport\") %&gt;%\n    e_x_axis(week, axisPointer = list(show = TRUE))\nts_base %&gt;% e_line(dep_delay)\n\n\n\n\n\n\n\nStacked area\nSwitching from line to area graphs is done in one line of code. It’s also possible to reuse chart elements.\n\narea &lt;- ts_base %&gt;% e_area(dep_delay, stack = \"grp\")\narea\n\n\n\n\n\n\n\nTimeline\nA standout feature of echarts is the timeline visualization. It’s somewhat similar to gganimate, but instead of videos it outputs an HTMLwidget with controls. Here, I used it to show weekly aggregated departure delays for JFK airport. One thing to look out for is that the timeline view doesn’t provide as much context as the classic time series graphs shown before. However, this focus on a single time period at a time also lends itself to data storytelling.\n\nflights_ts %&gt;%\n    filter(origin == \"JFK\") %&gt;%\n    group_by(month = month(week, label = TRUE)) %&gt;%\n    e_charts(x = week, timeline = TRUE) %&gt;%\n    e_bar(\n        dep_delay,\n        name = \"Departure Delay\",\n        symbol = \"none\",\n        legend = FALSE\n    )"
  },
  {
    "objectID": "posts/echarts4r/index.html#synchronized-plots",
    "href": "posts/echarts4r/index.html#synchronized-plots",
    "title": "Exploring echarts4r",
    "section": "Synchronized plots",
    "text": "Synchronized plots\nSimilar to the crosstalk package, echarts allows linking of plots. They share legend, sliders and data zooms. From my point of view, it’s easier to use but not as flexible. Crosstalk allows linking of any compatible HTMLWidgets like Leaflet maps and DT tables, while echarts is limited to echarts itself. When used in Shiny applications, the complex interactions can be handled by the server functions, so echarts can also be linked without limitations."
  },
  {
    "objectID": "posts/echarts4r/index.html#grab-bag",
    "href": "posts/echarts4r/index.html#grab-bag",
    "title": "Exploring echarts4r",
    "section": "Grab bag",
    "text": "Grab bag\nThis final section is a collection of various specialized graphs.\n\nCorrelation matrix\nThe convenient e_correlations() function combines e_heatmap() with corrMatOrder() from the corrplot package. As a specialized function, the original corrplot() function has many more options though, such as only displaying the upper of lower triangle and visualizing the results of statistical significance tests.\n\ncor_data &lt;- flights %&gt;%\n    select(arr_delay, dep_delay, air_time, distance, hour) %&gt;%\n    filter(complete.cases(.)) %&gt;%\n    magrittr::set_colnames(colnames(.) %&gt;% str_replace(\"_\", \" \") %&gt;% str_to_title()) %&gt;%\n    cor()\ncor_data %&gt;%\n    e_charts() %&gt;%\n    e_correlations(\n        visual_map = TRUE,\n        order = \"hclust\",\n        inRange = list(color = c(\"#edafda\", \"#eeeeee\", \"#59c4e6\")), # scale colors\n        itemStyle = list(\n            borderWidth = 2,\n            borderColor = \"#fff\"\n        )\n    ) %&gt;%\n    e_title(\"Correlation\")"
  },
  {
    "objectID": "posts/echarts4r/index.html#wordcloud",
    "href": "posts/echarts4r/index.html#wordcloud",
    "title": "Exploring echarts4r",
    "section": "Wordcloud",
    "text": "Wordcloud\nWordclouds fall in the same category as pie charts - a pretty, but imprecise display. A hover effect can add more detail by showing the precise word frequency. Here, I show the 50 top destinations by number of flights.\n\ntf &lt;- flights %&gt;%\n    count(dest, sort = TRUE) %&gt;%\n    head(50)\ntf %&gt;%\n    e_color_range(n, color, colors = c(\"#59c4e6\", \"#edafda\")) %&gt;%\n    e_charts() %&gt;%\n    e_cloud(\n        word = dest,\n        freq = n,\n        color = color,\n        shape = \"circle\",\n        rotationRange = c(0, 0),\n        sizeRange = c(8, 100)\n    ) %&gt;%\n    e_tooltip() %&gt;%\n    e_title(\"Flight destinations\")"
  },
  {
    "objectID": "posts/echarts4r/index.html#wrapup",
    "href": "posts/echarts4r/index.html#wrapup",
    "title": "Exploring echarts4r",
    "section": "Wrapup",
    "text": "Wrapup\nThe charts covered in this article are just a sample of the large variety of capabilities of echarts. There are many more examples on the official site and the echarts4r website. Personally, echarts4r will become my go-to for interactive HTML publications in R Markdown and Shiny. For static graphs I’ll stick with ggplot2 and vast ecosystem of extension packages, and for quick exploratory data analysis plotly’s ggplotly() is by far the easiest tool."
  },
  {
    "objectID": "imprint.html",
    "href": "imprint.html",
    "title": "Imprint",
    "section": "",
    "text": "Information pursuant to § 5 TMG\nPaul Simmering\nJägerhofallee 30\n71635 Ludwigsburg\n\n\nE-Mail: paul.simmering@gmail.com"
  },
  {
    "objectID": "imprint.html#contact",
    "href": "imprint.html#contact",
    "title": "Imprint",
    "section": "",
    "text": "E-Mail: paul.simmering@gmail.com"
  },
  {
    "objectID": "talks.html",
    "href": "talks.html",
    "title": "Talks",
    "section": "",
    "text": "Large Language Models for Aspect-Based Sentiment Analysis\n\n\n\n\n\n\nPaul Simmering and Paavo Huoviala\n\n\nSep 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAI for Social Media Monitoring at dm\n\n\n\n\n\n\nPaul Simmering\n\n\nNov 25, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStakeX - Organizational Networks from Web Research\n\n\n\n\n\n\nThomas Perry and Paul Simmering\n\n\nSep 28, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR Shiny for Interactive Data Visualization – A Case Study\n\n\n\n\n\n\nPaul Simmering\n\n\nMar 8, 2019\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHuman and AI Decision Making in a Game of Innovation and Imitation\n\n\n\n\n\n\nPaul Simmering\n\n\nSep 13, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInnovation and Imitation Strategies in the Age of the Upgrade – An Agent-Based Simulation Model\n\n\n\n\n\n\nPaul Simmering and Daniel S. Hain\n\n\nSep 27, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInnovation and Imitation Strategies in the Age of the Upgrade – An Agent-Based Simulation Model\n\n\n\n\n\n\n\n\n\nMay 31, 2017\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/texttunnel/index.html",
    "href": "projects/texttunnel/index.html",
    "title": "texttunnel Python package texttunnel",
    "section": "",
    "text": "texttunnel is a Python package for efficient interaction with the OpenAI API. I developed it in collaboration with Paavo Huoviala at Q Insight Agency.\nThe package is MIT-licensed and available on Github and PyPi.\nAn introduction with a business use case is available on the Q Insight Agency blog."
  },
  {
    "objectID": "projects/masterthesis/index.html",
    "href": "projects/masterthesis/index.html",
    "title": "Human and AI Decision Making in a Game of Innovation and Imitation",
    "section": "",
    "text": "My master thesis investigates the use of artificial intelligence (AI) in managerial decision making. The thesis was supervised by Assoc. Prof. Daniel S. Hain and Assoc. Prof. Roman Jurowetzki at Aalborg University.\nI also gave a talk about it at a Research Plus conference in Cologne. You can find the slides here.\nCurrent AI is narrow, specialized for single tasks and cannot be applied to others. However, recent developments in general game-playing algorithms suggest that AI will become more generally applicable. In managerial decision making, it could be used as a decision support systems or as an autonomous decision maker. This idea of an artificial business decision maker is studied along four research questions.\n\nHow do AI and human thought processes differ?\nDo AIs and humans make qualitatively different business decisions?\nWhat are the dynamics of competition and cooperation between humans and AI?\nAre there potential problems in value alignment between a business and its AI?\n\n\nThe study approaches these questions by example of a business game. You can play the game online here. The code for the game is available on Github.\nThe game depicts competition between two firms in a consumer goods market and emphasizes innovation and imitation strategies in product development, as well as vertical and horizontal product differentiation. It is played by an AI and human participants. The agent combines Monte Carlo Tree Search with prediction of outcomes using an artificial neural network. Six human participants played two games each against that agent. While playing, they gave a think-aloud protocol. The research questions are answered by combining insights from a content analysis of the protocols and an analysis of the AI’s architecture and processes.\nThe AI combines forward reasoning using tree search and evaluation of situations with artificial neural networks. This parallels humans’ thought processes that combine conscious, effortful thinking with unconscious, effortless evaluation. The differences lie in AI’s superior computational abilities, humans’ superior ability to learn from small samples and humans’ conscious and unconscious social behavior and emotions. The absence of this social behavior causes AI to act qualitatively differently – to consider actions that humans do not. This divergence can take the form of breaches of norms of reciprocity and unorthodox pursuit of a utility function. Instructing an AI is difficult, because humans have utility functions with many inputs that have complex relationships among each other, and may be unaware of elements until they come to bear. Value alignment is an on- going challenge for businesses and policy makers. Further, firms have to learn how to best incorporate AI in their decision making. This includes training employees in the use of AI assistants, developing transparent algorithms and developing an awareness for situations in which the use of AI is inappropriate for technical, legal or social reasons."
  },
  {
    "objectID": "projects/bachelorthesis/index.html",
    "href": "projects/bachelorthesis/index.html",
    "title": "Do Internet Users have a Positive Willingness-To-Pay for Ad-free Usage of Websites?",
    "section": "",
    "text": "I conducted an online survey and economic experiment and analyzed the results using logistic regression. The thesis was supervised by Prof. Dr. Gerhard Riener at University of Mannheim.\n\nPhoto by Justus Menke on Unsplash"
  },
  {
    "objectID": "projects/stakex/index.html",
    "href": "projects/stakex/index.html",
    "title": "StakeX - Organizational Networks from Web Research",
    "section": "",
    "text": "StakeX is a network analysis approach for public relations projects. It is in use at Q Insight Agency with clients in public transportation and the energy sector. The approach consists of:\n\nmethods for gathering public data on relevant stakeholders\nbuilding a network based on sociological theory\nanalyzing the network through use of force-based layout algorithms and centrality statistics\nextracting valuable insights for customers\n\nTo learn more about the method, see the slides of the talk by Thomas Perry and me or check the methods section of the demo app.\nI led the development of two Shiny apps for this project. The first is a CRUD app that facilitates data entry into a PostgreSQL database and ensures data integrity. The second is a platform for interactive data analysis featuring graphs with visNetwork and maps with leaflet. Both are hosted on EC2 instances on AWS.\nTech stack: R, PostgreSQL, AWS EC2"
  },
  {
    "objectID": "projects/cosmention/index.html",
    "href": "projects/cosmention/index.html",
    "title": "Cosmention",
    "section": "",
    "text": "Cosmention is an AI-powered social media monitoring tool for the cosmetics industry. A fully automated data pipeline starting from social media APIs and ending in a customizable dashboard.\n\nI am the inventor and lead developer and started the project as an independent SaaS offering. It was acquired by Q Insight Agency and is now in use at dm, the largest drug store chain in Europe.\nI presented the data pipeline in 2021 at the BVM (German association of social and market researchers) symposium on artificial intelligence and wrote an article on Marktforschung.de, the largest German market research website.\nTech stack: R, Shiny, spaCy (Python), AWS, Docker, Postgres, Snowflake"
  },
  {
    "objectID": "projects/gpexp/index.html",
    "href": "projects/gpexp/index.html",
    "title": "Global Patent Explorer",
    "section": "",
    "text": "Freeelance work for Aalborg University, commissioned by Assoc. Prof. Daniel S. Hain and Assoc. Prof. Roman Jurowetzki. The Shiny App visualizes the results of a paper on natural language processing on patent texts:\n\nD.S. Hain, R. Jurowetzki, T. Buchmann, P. Wolf (2018), A Vector Worth a Thousand Counts: A Temporal Semantic Similarity Approach to Patent Impact Prediction. Available at http://vbn.aau.dk/en/publications/a-vector-worth-a-thousand-counts(855d9758-d017-4b4a-baf5-8b7e72a1c223).html\n\n\nThe app’s code is available on Github.\nThis tool lets users map and visualize inventive and innovative activity around the globe. The explorer relies on a series of novel indicators that combine insights from large-scale natural language processing and established patent analysis techniques and provide insights about dimensions such as technological originality or future orientation. Users can explore the dataset on country or city level, select time-ranges and technologies. The app features rich visualizations including a world map, network plots that show relations between countries and cities, and customizable statistical plots.\nThe app is a winner of the first IPSDM (Intellectual property statistics for descision makers) “Big Data Analytics” Challenge (2018) by the European Union Intellectual Property Office.\n\nI also presented the app at the GOR 2019 conference. You can find the slides here.\nTech stack: R, Shiny"
  },
  {
    "objectID": "talks/researchplus2018/index.html",
    "href": "talks/researchplus2018/index.html",
    "title": "Human and AI Decision Making in a Game of Innovation and Imitation",
    "section": "",
    "text": "🗓️ Event\nResearch Plus by DGOF\n\n\n📅 Date\n13 September 2018\n\n\n📍 Location\nCologne, Germany\n\n\n📥 Materials\nSlides (PDF)\n\n\n💻 App\nBusiness Game\n\n\n\nA presentation of the research project I conducted at Aalborg University for my master thesis. I investigated the use of artificial intelligence (AI) in managerial decision making by example of a business game. Six human participants competed against an AI agent. The agent combines Monte Carlo Tree Search with prediction of outcomes using an artificial neural network. While playing, human participants gave a think-aloud protocol. Among other results, the study found architectural parallels in thought processes, qualitative differences in decisions due to AI’s lack of reciprocity, and potential problems in value alignment."
  },
  {
    "objectID": "talks/emaee2017/index.html",
    "href": "talks/emaee2017/index.html",
    "title": "Innovation and Imitation Strategies in the Age of the Upgrade – An Agent-Based Simulation Model",
    "section": "",
    "text": "🗓️ Event\n10th European Meeting on Applied Evolutionary Economics\n\n\n📅 Date\n31 May 2017\n\n\n📍 Location\nStrasbourg, France\n\n\n📥 Slides\nDownload\n\n\n📄 Paper\nDownload\n\n\n\nProduct life-cycles in markets for innovative products are shortening, con- sumers rapidly upgrade from one product generation to the next and demand constant technical improvement. Firms are racing against each other and the consumers’ rising ex- pectations. This study uses an agent-based simulation model to analyze the dynamics of innovation and imitation strategies in this new type of market from the firm perspective. Firms use pure and mixed strategies to achieve maximum profitability over the life-cycle of a market for a new product category. It is found that strategies involving innovation outperform those that rely only on imitation, even in absence of any protective measures like patenting or branding.\nPhoto by Patrick Robert Doyle on Unsplash"
  },
  {
    "objectID": "talks/gor2023/index.html",
    "href": "talks/gor2023/index.html",
    "title": "Large Language Models for Aspect-Based Sentiment Analysis",
    "section": "",
    "text": "🗓️ Event\nGeneral Online Research 2023\n\n\n📅 Date\n21 September 2023\n\n\n📍 Location\nKassel, Germany\n\n\n📥 Materials\nSlides (PDF)"
  },
  {
    "objectID": "talks/gor2023/index.html#relevance-research-question",
    "href": "talks/gor2023/index.html#relevance-research-question",
    "title": "Large Language Models for Aspect-Based Sentiment Analysis",
    "section": "Relevance & Research Question",
    "text": "Relevance & Research Question\nLarge language models (LLMs) like GPT-4 offer unprecedented text processing capabilities. As general models, they can fulfill a wide range of roles, including those of more specialized models. We investigated how well GPT-3.5 and 4 perform for aspect-based sentiment analysis (ABSA). ABSA is used for providing insights into digitized texts, such as product reviews or forum discussions, and is therefore a key capability for market research and computational social sciences."
  },
  {
    "objectID": "talks/gor2023/index.html#methods-data",
    "href": "talks/gor2023/index.html#methods-data",
    "title": "Large Language Models for Aspect-Based Sentiment Analysis",
    "section": "Methods & Data",
    "text": "Methods & Data\nWe assess performance of GPT-3.5 and 4 both quantitatively and qualitatively. We evaluate performance on the gold standard benchmark dataset SemEval2014, consisting of human annotated laptop and restaurant reviews. Model performance is measured on a joint aspect term extraction and polarity classification task. We vary the prompt and the number of examples used and investigate the cost-accuracy tradeoff. We manually classify the errors made by the model and characterize its strengths and weaknesses."
  },
  {
    "objectID": "talks/gor2023/index.html#results",
    "href": "talks/gor2023/index.html#results",
    "title": "Large Language Models for Aspect-Based Sentiment Analysis",
    "section": "Results",
    "text": "Results\nGiven 10 examples, GPT-4 outperforms BERT-based models trained on the full dataset, but does not reach the state of the art performance achieved by trained T5 models. The choice of prompt is crucial for performance and adding more examples improves performance further, however driving up the number of input tokens and therefore cost in the process. We discuss solutions such as bundling multiple prediction tasks into one prompt. GPT-4‘s errors are typically related to the idiosyncrasies of the benchmark dataset and extensive labeling rules. It struggles to pick up on the nuances of labeling rules, instead occasionally delivering more commonsense labels. While such errors hamper benchmark performance, they should not necessarily discourage from using LLMs in real-world applications of ABSA or similar tasks."
  },
  {
    "objectID": "talks/gor2023/index.html#added-value",
    "href": "talks/gor2023/index.html#added-value",
    "title": "Large Language Models for Aspect-Based Sentiment Analysis",
    "section": "Added Value",
    "text": "Added Value\nThis study provides market researchers evidence on the capabilities of LLMs for ABSA. It also provides practical hints for prompt engineering and the cost-accuracy tradeoffs involved when using LLMs for structured extraction and classification tasks. By extension, it also helps with placing few-shot use of LLMs in contrast with finetuned models."
  },
  {
    "objectID": "talks/comes2020/index.html",
    "href": "talks/comes2020/index.html",
    "title": "StakeX - Organizational Networks from Web Research",
    "section": "",
    "text": "🗓️ Event\nContent Meets Structure 2020\n\n\n📅 Date\n28 September 2020\n\n\n📍 Location\nHeidelberg, Germany\n\n\n📥 Materials\nSlides (PDF)\n\n\n🌐 App\nStakeX\n\n\n\nThomas Perry and me presented the StakeX method, which was developed at Q Insight Agency.\nPhoto by Alina Grubnyak on Unsplash"
  },
  {
    "objectID": "talks/gor2019/index.html",
    "href": "talks/gor2019/index.html",
    "title": "R Shiny for Interactive Data Visualization – A Case Study",
    "section": "",
    "text": "🗓️ Event\nGeneral Online Research 2019\n\n\n📅 Date\n8 March 2019\n\n\n📍 Location\nCologne, Germany\n\n\n📥 Materials\nSlides (PDF)\n\n\n💻 App\nPatent Explorer\n\n\n\nAn overview of R Shiny by example of an app I developed for display patent statistics\n\n\n\nPatent Explorer"
  },
  {
    "objectID": "talks/concordi2017/index.html",
    "href": "talks/concordi2017/index.html",
    "title": "Innovation and Imitation Strategies in the Age of the Upgrade – An Agent-Based Simulation Model",
    "section": "",
    "text": "🗓️ Event\n6th European Conference on Corporate R&D and Innovation\n\n\n📅 Date\n27-29 September 2017\n\n\n📍 Location\nSeville, Spain\n\n\n📥 Slides\nDownload\n\n\n\nPresentation of an agent based simulation game that models a competitive market with innovator and imitator agents.\nPreview photo by Joan Oger on Unsplash"
  },
  {
    "objectID": "talks/bvmki2021/index.html",
    "href": "talks/bvmki2021/index.html",
    "title": "AI for Social Media Monitoring at dm",
    "section": "",
    "text": "🗓️ Event\nBVM symposium: Understanding artificial intelligence and using it with sustained success\n\n\n📅 Date\n25 November 2021\n\n\n📍 Location\nOnline\n\n\n📥 Materials\nSlides (PDF)\n\n\n🌐 Website\nCosmention\n\n\n\nA presentation on Cosmention’s data pipeline and how Cosmention is used at dm, the largest drugstore chain in Europe. The presentation starts with a review of language models and word vectors and then dives into text classification and named entity recognition.\nPhoto by Christopher Burns on Unsplash"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "texttunnel Python package texttunnel\n\n\n\n\n\n\nPaul Simmering and Paavo Huoviala\n\n\nSep 21, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCosmention\n\n\n\n\n\n\nPaul Simmering\n\n\nMar 29, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStakeX - Organizational Networks from Web Research\n\n\n\n\n\n\nPaul Simmering\n\n\nSep 30, 2020\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGlobal Patent Explorer\n\n\n\n\n\n\nPaul Simmering\n\n\nJul 1, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHuman and AI Decision Making in a Game of Innovation and Imitation\n\n\n\n\n\n\nPaul Simmering\n\n\nFeb 1, 2018\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDo Internet Users have a Positive Willingness-To-Pay for Ad-free Usage of Websites?\n\n\n\n\n\n\nPaul Simmering\n\n\nAug 5, 2015\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "A Critical Evaluation of Github Copilot and GPT-4 in a Data Science Workflow\n\n\n\n\n\n\n\nproductivity\n\n\n\n\n\n\n\n\n\n\n\nApr 10, 2023\n\n\nPaul Simmering\n\n\n\n\n\n\n  \n\n\n\n\nTwitter API data collector with Modal\n\n\n\n\n\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2023\n\n\nPaul Simmering\n\n\n\n\n\n\n  \n\n\n\n\nInvesting in data science skills for the long run\n\n\n\n\n\n\n\nadvice\n\n\n\n\n\n\n\n\n\n\n\nJan 9, 2023\n\n\nPaul Simmering\n\n\n\n\n\n\n  \n\n\n\n\nTidy Tuesday: analyzing yarns with polars\n\n\n\n\n\n\n\npolars\n\n\nplotly\n\n\nTidyTuesday\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nOct 22, 2022\n\n\nPaul Simmering\n\n\n\n\n\n\n  \n\n\n\n\nFANGMANT: Tech stock analysis with pandas\n\n\n\n\n\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nDec 27, 2021\n\n\nPaul Simmering\n\n\n\n\n\n\n  \n\n\n\n\nData frame wars: Choosing a Python dataframe library as a dplyr user\n\n\n\n\n\n\n\nR\n\n\nPython\n\n\n\n\n\n\n\n\n\n\n\nDec 20, 2021\n\n\nPaul Simmering\n\n\n\n\n\n\n  \n\n\n\n\nExploring echarts4r\n\n\n\n\n\n\n\nR\n\n\nData visualization\n\n\n\n\n\n\n\n\n\n\n\nFeb 8, 2020\n\n\nPaul Simmering\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi! I’m Paul Simmering, a data scientist from Germany specializing in Natural Language Processing. Besides coding, I enjoy writing and speaking about data science.\nI’m the inventor and lead developer of Cosmention, an AI-powered social media monitoring tool for cosmetics. It’s a fully automated data pipeline for collecting social media posts, analyzing them with ML and reporting via dashboard and email. It’s in use at Europe’s largest drugstore chain dm Drogerie Markt.\nThe best way to contact me is via email: paul.simmering@gmail.com.\nWhat other than data science? Here are some things I enjoy:\n\nDesign and typography. Some examples: Berkeley Graphics, iA, Stripe’s website.\nContemporary art, particularly generative art and art inspired by geometry. My favorites are Kjetil Golid, Owen Pomery and Reuben Wu.\nParks and gardens, especially Japanese gardens.\nEuro-style games, Magic: The Gathering, Poker, Backgammon and other games that involve luck in a single game but are skill-based in the long run.\n\nThis website is built with Quarto. The source is available on Github."
  }
]